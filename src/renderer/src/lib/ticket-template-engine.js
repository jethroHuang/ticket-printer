var Ge = Object.defineProperty;
var $e = (r, u, i) => u in r ? Ge(r, u, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[u] = i;
var L = (r, u, i) => ($e(r, typeof u != "symbol" ? u + "" : u, i), i);
const Ae = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((r) => r.charCodeAt(0))
), Ie = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((r) => r.charCodeAt(0))
);
var Ju;
const ze = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), ue = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Ju = String.fromCodePoint) !== null && Ju !== void 0 ? Ju : function(r) {
    let u = "";
    return r > 65535 && (r -= 65536, u += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), u += String.fromCharCode(r), u;
  }
);
function Xe(r) {
  var u;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (u = ze.get(r)) !== null && u !== void 0 ? u : r;
}
var $;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})($ || ($ = {}));
const Qe = 32;
var mu;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(mu || (mu = {}));
function ee(r) {
  return r >= $.ZERO && r <= $.NINE;
}
function Je(r) {
  return r >= $.UPPER_A && r <= $.UPPER_F || r >= $.LOWER_A && r <= $.LOWER_F;
}
function Ze(r) {
  return r >= $.UPPER_A && r <= $.UPPER_Z || r >= $.LOWER_A && r <= $.LOWER_Z || ee(r);
}
function Ye(r) {
  return r === $.EQUALS || Ze(r);
}
var G;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(G || (G = {}));
var cu;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(cu || (cu = {}));
class Se {
  constructor(u, i, n) {
    this.decodeTree = u, this.emitCodePoint = i, this.errors = n, this.state = G.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = cu.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(u) {
    this.decodeMode = u, this.state = G.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(u, i) {
    switch (this.state) {
      case G.EntityStart:
        return u.charCodeAt(i) === $.NUM ? (this.state = G.NumericStart, this.consumed += 1, this.stateNumericStart(u, i + 1)) : (this.state = G.NamedEntity, this.stateNamedEntity(u, i));
      case G.NumericStart:
        return this.stateNumericStart(u, i);
      case G.NumericDecimal:
        return this.stateNumericDecimal(u, i);
      case G.NumericHex:
        return this.stateNumericHex(u, i);
      case G.NamedEntity:
        return this.stateNamedEntity(u, i);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(u, i) {
    return i >= u.length ? -1 : (u.charCodeAt(i) | Qe) === $.LOWER_X ? (this.state = G.NumericHex, this.consumed += 1, this.stateNumericHex(u, i + 1)) : (this.state = G.NumericDecimal, this.stateNumericDecimal(u, i));
  }
  addToNumericResult(u, i, n, o) {
    if (i !== n) {
      const l = n - i;
      this.result = this.result * Math.pow(o, l) + parseInt(u.substr(i, l), o), this.consumed += l;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(u, i) {
    const n = i;
    for (; i < u.length; ) {
      const o = u.charCodeAt(i);
      if (ee(o) || Je(o))
        i += 1;
      else
        return this.addToNumericResult(u, n, i, 16), this.emitNumericEntity(o, 3);
    }
    return this.addToNumericResult(u, n, i, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(u, i) {
    const n = i;
    for (; i < u.length; ) {
      const o = u.charCodeAt(i);
      if (ee(o))
        i += 1;
      else
        return this.addToNumericResult(u, n, i, 10), this.emitNumericEntity(o, 2);
    }
    return this.addToNumericResult(u, n, i, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(u, i) {
    var n;
    if (this.consumed <= i)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (u === $.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === cu.Strict)
      return 0;
    return this.emitCodePoint(Xe(this.result), this.consumed), this.errors && (u !== $.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(u, i) {
    const { decodeTree: n } = this;
    let o = n[this.treeIndex], l = (o & mu.VALUE_LENGTH) >> 14;
    for (; i < u.length; i++, this.excess++) {
      const f = u.charCodeAt(i);
      if (this.treeIndex = Ke(n, o, this.treeIndex + Math.max(1, l), f), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === cu.Attribute && // We shouldn't have consumed any characters after the entity,
        (l === 0 || // And there should be no invalid characters.
        Ye(f)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (o = n[this.treeIndex], l = (o & mu.VALUE_LENGTH) >> 14, l !== 0) {
        if (f === $.SEMI)
          return this.emitNamedEntityData(this.treeIndex, l, this.consumed + this.excess);
        this.decodeMode !== cu.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var u;
    const { result: i, decodeTree: n } = this, o = (n[i] & mu.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(i, o, this.consumed), (u = this.errors) === null || u === void 0 || u.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(u, i, n) {
    const { decodeTree: o } = this;
    return this.emitCodePoint(i === 1 ? o[u] & ~mu.VALUE_LENGTH : o[u + 1], n), i === 3 && this.emitCodePoint(o[u + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var u;
    switch (this.state) {
      case G.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== cu.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case G.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case G.NumericHex:
        return this.emitNumericEntity(0, 3);
      case G.NumericStart:
        return (u = this.errors) === null || u === void 0 || u.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case G.EntityStart:
        return 0;
    }
  }
}
function ve(r) {
  let u = "";
  const i = new Se(r, (n) => u += ue(n));
  return function(o, l) {
    let f = 0, s = 0;
    for (; (s = o.indexOf("&", s)) >= 0; ) {
      u += o.slice(f, s), i.startEntity(l);
      const w = i.write(
        o,
        // Skip the "&"
        s + 1
      );
      if (w < 0) {
        f = s + i.end();
        break;
      }
      f = s + w, s = w === 0 ? f + 1 : f;
    }
    const m = u + o.slice(f);
    return u = "", m;
  };
}
function Ke(r, u, i, n) {
  const o = (u & mu.BRANCH_LENGTH) >> 7, l = u & mu.JUMP_TABLE;
  if (o === 0)
    return l !== 0 && n === l ? i : -1;
  if (l) {
    const m = n - l;
    return m < 0 || m >= o ? -1 : r[i + m] - 1;
  }
  let f = i, s = f + o - 1;
  for (; f <= s; ) {
    const m = f + s >>> 1, w = r[m];
    if (w < n)
      f = m + 1;
    else if (w > n)
      s = m - 1;
    else
      return r[m + o];
  }
  return -1;
}
ve(Ae);
ve(Ie);
var T;
(function(r) {
  r[r.Tab = 9] = "Tab", r[r.NewLine = 10] = "NewLine", r[r.FormFeed = 12] = "FormFeed", r[r.CarriageReturn = 13] = "CarriageReturn", r[r.Space = 32] = "Space", r[r.ExclamationMark = 33] = "ExclamationMark", r[r.Number = 35] = "Number", r[r.Amp = 38] = "Amp", r[r.SingleQuote = 39] = "SingleQuote", r[r.DoubleQuote = 34] = "DoubleQuote", r[r.Dash = 45] = "Dash", r[r.Slash = 47] = "Slash", r[r.Zero = 48] = "Zero", r[r.Nine = 57] = "Nine", r[r.Semi = 59] = "Semi", r[r.Lt = 60] = "Lt", r[r.Eq = 61] = "Eq", r[r.Gt = 62] = "Gt", r[r.Questionmark = 63] = "Questionmark", r[r.UpperA = 65] = "UpperA", r[r.LowerA = 97] = "LowerA", r[r.UpperF = 70] = "UpperF", r[r.LowerF = 102] = "LowerF", r[r.UpperZ = 90] = "UpperZ", r[r.LowerZ = 122] = "LowerZ", r[r.LowerX = 120] = "LowerX", r[r.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(T || (T = {}));
var g;
(function(r) {
  r[r.Text = 1] = "Text", r[r.BeforeTagName = 2] = "BeforeTagName", r[r.InTagName = 3] = "InTagName", r[r.InSelfClosingTag = 4] = "InSelfClosingTag", r[r.BeforeClosingTagName = 5] = "BeforeClosingTagName", r[r.InClosingTagName = 6] = "InClosingTagName", r[r.AfterClosingTagName = 7] = "AfterClosingTagName", r[r.BeforeAttributeName = 8] = "BeforeAttributeName", r[r.InAttributeName = 9] = "InAttributeName", r[r.AfterAttributeName = 10] = "AfterAttributeName", r[r.BeforeAttributeValue = 11] = "BeforeAttributeValue", r[r.InAttributeValueDq = 12] = "InAttributeValueDq", r[r.InAttributeValueSq = 13] = "InAttributeValueSq", r[r.InAttributeValueNq = 14] = "InAttributeValueNq", r[r.BeforeDeclaration = 15] = "BeforeDeclaration", r[r.InDeclaration = 16] = "InDeclaration", r[r.InProcessingInstruction = 17] = "InProcessingInstruction", r[r.BeforeComment = 18] = "BeforeComment", r[r.CDATASequence = 19] = "CDATASequence", r[r.InSpecialComment = 20] = "InSpecialComment", r[r.InCommentLike = 21] = "InCommentLike", r[r.BeforeSpecialS = 22] = "BeforeSpecialS", r[r.SpecialStartSequence = 23] = "SpecialStartSequence", r[r.InSpecialTag = 24] = "InSpecialTag", r[r.InEntity = 25] = "InEntity";
})(g || (g = {}));
function du(r) {
  return r === T.Space || r === T.NewLine || r === T.Tab || r === T.FormFeed || r === T.CarriageReturn;
}
function ju(r) {
  return r === T.Slash || r === T.Gt || du(r);
}
function u0(r) {
  return r >= T.LowerA && r <= T.LowerZ || r >= T.UpperA && r <= T.UpperZ;
}
var su;
(function(r) {
  r[r.NoValue = 0] = "NoValue", r[r.Unquoted = 1] = "Unquoted", r[r.Single = 2] = "Single", r[r.Double = 3] = "Double";
})(su || (su = {}));
const Q = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
class e0 {
  constructor({ xmlMode: u = !1, decodeEntities: i = !0 }, n) {
    this.cbs = n, this.state = g.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = g.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = u, this.decodeEntities = i, this.entityDecoder = new Se(u ? Ie : Ae, (o, l) => this.emitCodePoint(o, l));
  }
  reset() {
    this.state = g.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = g.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
  }
  write(u) {
    this.offset += this.buffer.length, this.buffer = u, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = !1;
  }
  resume() {
    this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(u) {
    u === T.Lt || !this.decodeEntities && this.fastForwardTo(T.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = g.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && u === T.Amp && this.startEntity();
  }
  stateSpecialStartSequence(u) {
    const i = this.sequenceIndex === this.currentSequence.length;
    if (!(i ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      ju(u)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (u | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = !1;
    else if (!i) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = g.InTagName, this.stateInTagName(u);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(u) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (u === T.Gt || du(u)) {
        const i = this.index - this.currentSequence.length;
        if (this.sectionStart < i) {
          const n = this.index;
          this.index = i, this.cbs.ontext(this.sectionStart, i), this.index = n;
        }
        this.isSpecial = !1, this.sectionStart = i + 2, this.stateInClosingTagName(u);
        return;
      }
      this.sequenceIndex = 0;
    }
    (u | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === Q.TitleEnd ? this.decodeEntities && u === T.Amp && this.startEntity() : this.fastForwardTo(T.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(u === T.Lt);
  }
  stateCDATASequence(u) {
    u === Q.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === Q.Cdata.length && (this.state = g.InCommentLike, this.currentSequence = Q.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = g.InDeclaration, this.stateInDeclaration(u));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(u) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === u)
        return !0;
    return this.index = this.buffer.length + this.offset - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(u) {
    u === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === Q.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = g.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : u !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(u) {
    return this.xmlMode ? !ju(u) : u0(u);
  }
  startSpecial(u, i) {
    this.isSpecial = !0, this.currentSequence = u, this.sequenceIndex = i, this.state = g.SpecialStartSequence;
  }
  stateBeforeTagName(u) {
    if (u === T.ExclamationMark)
      this.state = g.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (u === T.Questionmark)
      this.state = g.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(u)) {
      const i = u | 32;
      this.sectionStart = this.index, !this.xmlMode && i === Q.TitleEnd[2] ? this.startSpecial(Q.TitleEnd, 3) : this.state = !this.xmlMode && i === Q.ScriptEnd[2] ? g.BeforeSpecialS : g.InTagName;
    } else
      u === T.Slash ? this.state = g.BeforeClosingTagName : (this.state = g.Text, this.stateText(u));
  }
  stateInTagName(u) {
    ju(u) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u));
  }
  stateBeforeClosingTagName(u) {
    du(u) || (u === T.Gt ? this.state = g.Text : (this.state = this.isTagStartChar(u) ? g.InClosingTagName : g.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(u) {
    (u === T.Gt || du(u)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = g.AfterClosingTagName, this.stateAfterClosingTagName(u));
  }
  stateAfterClosingTagName(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(u) {
    u === T.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = g.InSpecialTag, this.sequenceIndex = 0) : this.state = g.Text, this.sectionStart = this.index + 1) : u === T.Slash ? this.state = g.InSelfClosingTag : du(u) || (this.state = g.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(u) {
    u === T.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = g.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : du(u) || (this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u));
  }
  stateInAttributeName(u) {
    (u === T.Eq || ju(u)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = g.AfterAttributeName, this.stateAfterAttributeName(u));
  }
  stateAfterAttributeName(u) {
    u === T.Eq ? this.state = g.BeforeAttributeValue : u === T.Slash || u === T.Gt ? (this.cbs.onattribend(su.NoValue, this.index), this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u)) : du(u) || (this.cbs.onattribend(su.NoValue, this.index), this.state = g.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(u) {
    u === T.DoubleQuote ? (this.state = g.InAttributeValueDq, this.sectionStart = this.index + 1) : u === T.SingleQuote ? (this.state = g.InAttributeValueSq, this.sectionStart = this.index + 1) : du(u) || (this.sectionStart = this.index, this.state = g.InAttributeValueNq, this.stateInAttributeValueNoQuotes(u));
  }
  handleInAttributeValue(u, i) {
    u === i || !this.decodeEntities && this.fastForwardTo(i) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(i === T.DoubleQuote ? su.Double : su.Single, this.index), this.state = g.BeforeAttributeName) : this.decodeEntities && u === T.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(u) {
    this.handleInAttributeValue(u, T.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(u) {
    this.handleInAttributeValue(u, T.SingleQuote);
  }
  stateInAttributeValueNoQuotes(u) {
    du(u) || u === T.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(su.Unquoted, this.index), this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u)) : this.decodeEntities && u === T.Amp && this.startEntity();
  }
  stateBeforeDeclaration(u) {
    u === T.OpeningSquareBracket ? (this.state = g.CDATASequence, this.sequenceIndex = 0) : this.state = u === T.Dash ? g.BeforeComment : g.InDeclaration;
  }
  stateInDeclaration(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(u) {
    u === T.Dash ? (this.state = g.InCommentLike, this.currentSequence = Q.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = g.InDeclaration;
  }
  stateInSpecialComment(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(u) {
    const i = u | 32;
    i === Q.ScriptEnd[3] ? this.startSpecial(Q.ScriptEnd, 4) : i === Q.StyleEnd[3] ? this.startSpecial(Q.StyleEnd, 4) : (this.state = g.InTagName, this.stateInTagName(u));
  }
  startEntity() {
    this.baseState = this.state, this.state = g.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? cu.Strict : this.baseState === g.Text || this.baseState === g.InSpecialTag ? cu.Legacy : cu.Attribute);
  }
  stateInEntity() {
    const u = this.entityDecoder.write(this.buffer, this.index - this.offset);
    u >= 0 ? (this.state = this.baseState, u === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === g.Text || this.state === g.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === g.InAttributeValueDq || this.state === g.InAttributeValueSq || this.state === g.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const u = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case g.Text: {
          this.stateText(u);
          break;
        }
        case g.SpecialStartSequence: {
          this.stateSpecialStartSequence(u);
          break;
        }
        case g.InSpecialTag: {
          this.stateInSpecialTag(u);
          break;
        }
        case g.CDATASequence: {
          this.stateCDATASequence(u);
          break;
        }
        case g.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(u);
          break;
        }
        case g.InAttributeName: {
          this.stateInAttributeName(u);
          break;
        }
        case g.InCommentLike: {
          this.stateInCommentLike(u);
          break;
        }
        case g.InSpecialComment: {
          this.stateInSpecialComment(u);
          break;
        }
        case g.BeforeAttributeName: {
          this.stateBeforeAttributeName(u);
          break;
        }
        case g.InTagName: {
          this.stateInTagName(u);
          break;
        }
        case g.InClosingTagName: {
          this.stateInClosingTagName(u);
          break;
        }
        case g.BeforeTagName: {
          this.stateBeforeTagName(u);
          break;
        }
        case g.AfterAttributeName: {
          this.stateAfterAttributeName(u);
          break;
        }
        case g.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(u);
          break;
        }
        case g.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(u);
          break;
        }
        case g.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(u);
          break;
        }
        case g.AfterClosingTagName: {
          this.stateAfterClosingTagName(u);
          break;
        }
        case g.BeforeSpecialS: {
          this.stateBeforeSpecialS(u);
          break;
        }
        case g.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(u);
          break;
        }
        case g.InSelfClosingTag: {
          this.stateInSelfClosingTag(u);
          break;
        }
        case g.InDeclaration: {
          this.stateInDeclaration(u);
          break;
        }
        case g.BeforeDeclaration: {
          this.stateBeforeDeclaration(u);
          break;
        }
        case g.BeforeComment: {
          this.stateBeforeComment(u);
          break;
        }
        case g.InProcessingInstruction: {
          this.stateInProcessingInstruction(u);
          break;
        }
        case g.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === g.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const u = this.buffer.length + this.offset;
    this.sectionStart >= u || (this.state === g.InCommentLike ? this.currentSequence === Q.CdataEnd ? this.cbs.oncdata(this.sectionStart, u, 0) : this.cbs.oncomment(this.sectionStart, u, 0) : this.state === g.InTagName || this.state === g.BeforeAttributeName || this.state === g.BeforeAttributeValue || this.state === g.AfterAttributeName || this.state === g.InAttributeName || this.state === g.InAttributeValueSq || this.state === g.InAttributeValueDq || this.state === g.InAttributeValueNq || this.state === g.InClosingTagName || this.cbs.ontext(this.sectionStart, u));
  }
  emitCodePoint(u, i) {
    this.baseState !== g.Text && this.baseState !== g.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + i, this.index = this.sectionStart - 1, this.cbs.onattribentity(u)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + i, this.index = this.sectionStart - 1, this.cbs.ontextentity(u, this.sectionStart));
  }
}
const Bu = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), F = /* @__PURE__ */ new Set(["p"]), oe = /* @__PURE__ */ new Set(["thead", "tbody"]), fe = /* @__PURE__ */ new Set(["dd", "dt"]), de = /* @__PURE__ */ new Set(["rt", "rp"]), t0 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", F],
  ["h1", F],
  ["h2", F],
  ["h3", F],
  ["h4", F],
  ["h5", F],
  ["h6", F],
  ["select", Bu],
  ["input", Bu],
  ["output", Bu],
  ["button", Bu],
  ["datalist", Bu],
  ["textarea", Bu],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", fe],
  ["dt", fe],
  ["address", F],
  ["article", F],
  ["aside", F],
  ["blockquote", F],
  ["details", F],
  ["div", F],
  ["dl", F],
  ["fieldset", F],
  ["figcaption", F],
  ["figure", F],
  ["footer", F],
  ["form", F],
  ["header", F],
  ["hr", F],
  ["main", F],
  ["nav", F],
  ["ol", F],
  ["pre", F],
  ["section", F],
  ["table", F],
  ["ul", F],
  ["rt", de],
  ["rp", de],
  ["tbody", oe],
  ["tfoot", oe]
]), r0 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), le = /* @__PURE__ */ new Set(["math", "svg"]), he = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), i0 = /\s|\//;
class a0 {
  constructor(u, i = {}) {
    var n, o, l, f, s;
    this.options = i, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = u ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (n = i.lowerCaseTags) !== null && n !== void 0 ? n : this.htmlMode, this.lowerCaseAttributeNames = (o = i.lowerCaseAttributeNames) !== null && o !== void 0 ? o : this.htmlMode, this.tokenizer = new ((l = i.Tokenizer) !== null && l !== void 0 ? l : e0)(this.options, this), this.foreignContext = [!this.htmlMode], (s = (f = this.cbs).onparserinit) === null || s === void 0 || s.call(f, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(u, i) {
    var n, o;
    const l = this.getSlice(u, i);
    this.endIndex = i - 1, (o = (n = this.cbs).ontext) === null || o === void 0 || o.call(n, l), this.startIndex = i;
  }
  /** @internal */
  ontextentity(u, i) {
    var n, o;
    this.endIndex = i - 1, (o = (n = this.cbs).ontext) === null || o === void 0 || o.call(n, ue(u)), this.startIndex = i;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(u) {
    return this.htmlMode && r0.has(u);
  }
  /** @internal */
  onopentagname(u, i) {
    this.endIndex = i;
    let n = this.getSlice(u, i);
    this.lowerCaseTagNames && (n = n.toLowerCase()), this.emitOpenTag(n);
  }
  emitOpenTag(u) {
    var i, n, o, l;
    this.openTagStart = this.startIndex, this.tagname = u;
    const f = this.htmlMode && t0.get(u);
    if (f)
      for (; this.stack.length > 0 && f.has(this.stack[0]); ) {
        const s = this.stack.shift();
        (n = (i = this.cbs).onclosetag) === null || n === void 0 || n.call(i, s, !0);
      }
    this.isVoidElement(u) || (this.stack.unshift(u), this.htmlMode && (le.has(u) ? this.foreignContext.unshift(!0) : he.has(u) && this.foreignContext.unshift(!1))), (l = (o = this.cbs).onopentagname) === null || l === void 0 || l.call(o, u), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(u) {
    var i, n;
    this.startIndex = this.openTagStart, this.attribs && ((n = (i = this.cbs).onopentag) === null || n === void 0 || n.call(i, this.tagname, this.attribs, u), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
  }
  /** @internal */
  onopentagend(u) {
    this.endIndex = u, this.endOpenTag(!1), this.startIndex = u + 1;
  }
  /** @internal */
  onclosetag(u, i) {
    var n, o, l, f, s, m, w, I;
    this.endIndex = i;
    let y = this.getSlice(u, i);
    if (this.lowerCaseTagNames && (y = y.toLowerCase()), this.htmlMode && (le.has(y) || he.has(y)) && this.foreignContext.shift(), this.isVoidElement(y))
      this.htmlMode && y === "br" && ((f = (l = this.cbs).onopentagname) === null || f === void 0 || f.call(l, "br"), (m = (s = this.cbs).onopentag) === null || m === void 0 || m.call(s, "br", {}, !0), (I = (w = this.cbs).onclosetag) === null || I === void 0 || I.call(w, "br", !1));
    else {
      const q = this.stack.indexOf(y);
      if (q !== -1)
        for (let B = 0; B <= q; B++) {
          const v = this.stack.shift();
          (o = (n = this.cbs).onclosetag) === null || o === void 0 || o.call(n, v, B !== q);
        }
      else
        this.htmlMode && y === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
    }
    this.startIndex = i + 1;
  }
  /** @internal */
  onselfclosingtag(u) {
    this.endIndex = u, this.options.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(!1), this.startIndex = u + 1) : this.onopentagend(u);
  }
  closeCurrentTag(u) {
    var i, n;
    const o = this.tagname;
    this.endOpenTag(u), this.stack[0] === o && ((n = (i = this.cbs).onclosetag) === null || n === void 0 || n.call(i, o, !u), this.stack.shift());
  }
  /** @internal */
  onattribname(u, i) {
    this.startIndex = u;
    const n = this.getSlice(u, i);
    this.attribname = this.lowerCaseAttributeNames ? n.toLowerCase() : n;
  }
  /** @internal */
  onattribdata(u, i) {
    this.attribvalue += this.getSlice(u, i);
  }
  /** @internal */
  onattribentity(u) {
    this.attribvalue += ue(u);
  }
  /** @internal */
  onattribend(u, i) {
    var n, o;
    this.endIndex = i, (o = (n = this.cbs).onattribute) === null || o === void 0 || o.call(n, this.attribname, this.attribvalue, u === su.Double ? '"' : u === su.Single ? "'" : u === su.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(u) {
    const i = u.search(i0);
    let n = i < 0 ? u : u.substr(0, i);
    return this.lowerCaseTagNames && (n = n.toLowerCase()), n;
  }
  /** @internal */
  ondeclaration(u, i) {
    this.endIndex = i;
    const n = this.getSlice(u, i);
    if (this.cbs.onprocessinginstruction) {
      const o = this.getInstructionName(n);
      this.cbs.onprocessinginstruction(`!${o}`, `!${n}`);
    }
    this.startIndex = i + 1;
  }
  /** @internal */
  onprocessinginstruction(u, i) {
    this.endIndex = i;
    const n = this.getSlice(u, i);
    if (this.cbs.onprocessinginstruction) {
      const o = this.getInstructionName(n);
      this.cbs.onprocessinginstruction(`?${o}`, `?${n}`);
    }
    this.startIndex = i + 1;
  }
  /** @internal */
  oncomment(u, i, n) {
    var o, l, f, s;
    this.endIndex = i, (l = (o = this.cbs).oncomment) === null || l === void 0 || l.call(o, this.getSlice(u, i - n)), (s = (f = this.cbs).oncommentend) === null || s === void 0 || s.call(f), this.startIndex = i + 1;
  }
  /** @internal */
  oncdata(u, i, n) {
    var o, l, f, s, m, w, I, y, q, B;
    this.endIndex = i;
    const v = this.getSlice(u, i - n);
    !this.htmlMode || this.options.recognizeCDATA ? ((l = (o = this.cbs).oncdatastart) === null || l === void 0 || l.call(o), (s = (f = this.cbs).ontext) === null || s === void 0 || s.call(f, v), (w = (m = this.cbs).oncdataend) === null || w === void 0 || w.call(m)) : ((y = (I = this.cbs).oncomment) === null || y === void 0 || y.call(I, `[CDATA[${v}]]`), (B = (q = this.cbs).oncommentend) === null || B === void 0 || B.call(q)), this.startIndex = i + 1;
  }
  /** @internal */
  onend() {
    var u, i;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let n = 0; n < this.stack.length; n++)
        this.cbs.onclosetag(this.stack[n], !0);
    }
    (i = (u = this.cbs).onend) === null || i === void 0 || i.call(u);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var u, i, n, o;
    (i = (u = this.cbs).onreset) === null || i === void 0 || i.call(u), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (o = (n = this.cbs).onparserinit) === null || o === void 0 || o.call(n, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(u) {
    this.reset(), this.end(u);
  }
  getSlice(u, i) {
    for (; u - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let n = this.buffers[0].slice(u - this.bufferOffset, i - this.bufferOffset);
    for (; i - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), n += this.buffers[0].slice(0, i - this.bufferOffset);
    return n;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(u) {
    var i, n;
    if (this.ended) {
      (n = (i = this.cbs).onerror) === null || n === void 0 || n.call(i, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(u), this.tokenizer.running && (this.tokenizer.write(u), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(u) {
    var i, n;
    if (this.ended) {
      (n = (i = this.cbs).onerror) === null || n === void 0 || n.call(i, new Error(".end() after done!"));
      return;
    }
    u && this.write(u), this.ended = !0, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(u) {
    this.write(u);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(u) {
    this.end(u);
  }
}
var be = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function n0(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function c0(r) {
  if (r.__esModule)
    return r;
  var u = r.default;
  if (typeof u == "function") {
    var i = function n() {
      return this instanceof n ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    i.prototype = u.prototype;
  } else
    i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(i, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), i;
}
var Te = {}, pe = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, s0 = /\n/g, o0 = /^\s*/, f0 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, d0 = /^:\s*/, l0 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, h0 = /^[;\s]*/, b0 = /^\s+|\s+$/g, p0 = `
`, me = "/", xe = "*", Au = "", m0 = "comment", x0 = "declaration", g0 = function(r, u) {
  if (typeof r != "string")
    throw new TypeError("First argument must be a string");
  if (!r)
    return [];
  u = u || {};
  var i = 1, n = 1;
  function o(v) {
    var S = v.match(s0);
    S && (i += S.length);
    var C = v.lastIndexOf(p0);
    n = ~C ? v.length - C : n + v.length;
  }
  function l() {
    var v = { line: i, column: n };
    return function(S) {
      return S.position = new f(v), w(), S;
    };
  }
  function f(v) {
    this.start = v, this.end = { line: i, column: n }, this.source = u.source;
  }
  f.prototype.content = r;
  function s(v) {
    var S = new Error(
      u.source + ":" + i + ":" + n + ": " + v
    );
    if (S.reason = v, S.filename = u.source, S.line = i, S.column = n, S.source = r, !u.silent)
      throw S;
  }
  function m(v) {
    var S = v.exec(r);
    if (S) {
      var C = S[0];
      return o(C), r = r.slice(C.length), S;
    }
  }
  function w() {
    m(o0);
  }
  function I(v) {
    var S;
    for (v = v || []; S = y(); )
      S !== !1 && v.push(S);
    return v;
  }
  function y() {
    var v = l();
    if (!(me != r.charAt(0) || xe != r.charAt(1))) {
      for (var S = 2; Au != r.charAt(S) && (xe != r.charAt(S) || me != r.charAt(S + 1)); )
        ++S;
      if (S += 2, Au === r.charAt(S - 1))
        return s("End of comment missing");
      var C = r.slice(2, S - 2);
      return n += 2, o(C), r = r.slice(S), n += 2, v({
        type: m0,
        comment: C
      });
    }
  }
  function q() {
    var v = l(), S = m(f0);
    if (S) {
      if (y(), !m(d0))
        return s("property missing ':'");
      var C = m(l0), H = v({
        type: x0,
        property: ge(S[0].replace(pe, Au)),
        value: C ? ge(C[0].replace(pe, Au)) : Au
      });
      return m(h0), H;
    }
  }
  function B() {
    var v = [];
    I(v);
    for (var S; S = q(); )
      S !== !1 && (v.push(S), I(v));
    return v;
  }
  return w(), B();
};
function ge(r) {
  return r ? r.replace(b0, Au) : Au;
}
var w0 = be && be.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Te, "__esModule", { value: !0 });
var y0 = w0(g0);
function E0(r, u) {
  var i = null;
  if (!r || typeof r != "string")
    return i;
  var n = (0, y0.default)(r), o = typeof u == "function";
  return n.forEach(function(l) {
    if (l.type === "declaration") {
      var f = l.property, s = l.value;
      o ? u(f, s, l) : s && (i = i || {}, i[f] = s);
    }
  }), i;
}
var we = Te.default = E0;
const A0 = we.default || we;
class I0 extends Error {
  constructor(u) {
    super(), this.message = u;
  }
  toString() {
    return "ParseError: " + this.message;
  }
}
class Et extends Error {
  constructor(u) {
    super(), this.message = u;
  }
  toString() {
    return "LayoutError: " + this.message;
  }
}
class Be {
  /**
   * 创建一个节点
   * @param {string} type
   * @param {string} display
   */
  constructor(u, i) {
    this.type = u, this.display = i;
  }
}
class _e extends Be {
  /**
   * 创建一个文本节点
   * @param text 文本内容
   */
  constructor(u) {
    super(Pu.Text, xu.Inline), this.text = u;
  }
}
class Gu extends Be {
  /**
   * 创建一个普通节点
   * @param {string} tag
   * @param {Object} attrs
   * @param {string} display
   * @param {Object} style
   * @param {Array<NodeModel>} children
   */
  constructor(i, {
    attrs: n = {},
    style: o = {},
    display: l = xu.Block,
    children: f = []
  } = {}) {
    super(Pu.Element, l);
    L(this, "style", {});
    L(this, "attrs", {});
    L(this, "children", []);
    L(this, "tag", "");
    this.tag = i, this.attrs = n, this.style = Object.freeze(o), this.children = f;
  }
}
class Pu {
}
L(Pu, "Text", "text"), L(Pu, "Element", "element");
class xu {
}
L(xu, "Block", "block"), L(xu, "Inline", "inline");
class Fu {
  /**
   * 构建模型
   * @param {String} type is PrintType
   * @param {String | Array} content
   */
  constructor(u, i) {
    /**
     * 打印节点类型
     * @type {string}
     */
    L(this, "type");
    /**
     * 打印节点内容
     * @type {string | Array}
     */
    L(this, "content");
    this.type = u, this.content = i;
  }
}
class Eu extends Fu {
  /**
   * 创建一个文本打印节点
   * @param {Array<TextChildPrintNodeModel>} content 子文本，文本内容数组。
   * @param {string} align 对齐方式
   * @param {boolean} isBr 是否为换行符
   */
  constructor(i, {
    align: n = "left",
    isBr: o = !1
  } = {}) {
    super(K.text, i || []);
    /**
     * 对齐方式
     * @type {string}
     */
    L(this, "align", "left");
    /**
     * 是否为换行符
     * @type {boolean}
     */
    L(this, "isBr", !1);
    this.align = n, this.isBr = o;
  }
}
class pu extends Fu {
  /**
   * 创建一个文本子节点
   * @param {string} content 文本内容
   * @param {string} align 对齐方式
   * @param {string} fontSize 字体大小，仅rem单位，且值为整数。如：1rem，2rem，3rem。这表示将字放大的倍数
   * @param {boolean} isBold 是否加粗
   * @param {number} scaleWidth 宽度缩放倍数，仅支持整数
   * @param {number} scaleHeight 高度缩放倍数，仅支持整数
   * @param {string} fontStyle 字体样式，normal：正常，italic：斜体
   * @param {string} textDecorationLine 文本修饰，none：无，underline：下划线，line-through：删除线
   */
  constructor(i, {
    fontSize: n = "1rem",
    isBold: o = !1,
    scaleWidth: l = 1,
    scaleHeight: f = 1,
    fontStyle: s = Cu.normal,
    textDecorationLine: m = Nu.none
  } = {}) {
    super(K.textSpan, i);
    L(this, "fontSize", "1rem");
    L(this, "isBold", !1);
    L(this, "scaleWidth", 1);
    L(this, "scaleHeight", 1);
    L(this, "fontStyle", Cu.normal);
    L(this, "textDecorationLine", Nu.none);
    this.fontSize = n, this.isBold = o, this.scaleWidth = l, this.scaleHeight = f, this.fontStyle = s, this.textDecorationLine = m;
  }
  /**
   * 根据css样式创建一个文本子节点
   * @param {Object} css css样式
   * @param {string} content 可选参数，文本内容
   * @returns {TextChildPrintNodeModel}
   */
  static fromCss(i = {}, n = "") {
    let o = i["font-size"] || "1rem", l = i["font-weight"] === "bold" || i["font-weight"] === "600", f = i["scale-width"] || 1, s = i["scale-height"] || 1, m = i["font-style"] || Cu.normal, w = i["text-decoration-line"] || Nu.none;
    return new pu(n, {
      fontSize: o,
      isBold: l,
      scaleWidth: parseInt(f),
      scaleHeight: parseInt(s),
      fontStyle: m,
      textDecorationLine: w
    });
  }
}
class S0 extends Fu {
  /**
   * 创建一个图片打印节点
   * @param content 图片内容，可以是base64，也可以是图片地址
   * @param width 宽度，单位mm
   * @param height 高度，单位mm
   */
  constructor(u, {
    width: i = "30mm",
    height: n = "30mm"
  }) {
    super(K.image, u), this.width = i, this.height = n;
  }
}
class v0 extends Fu {
  /**
   * 创建一个二维码打印节点
   * @param content 二维码内容
   * @param width 宽度，单位mm
   * @param height 高度，单位mm
   */
  constructor(u, {
    width: i = "30mm",
    height: n = "30mm"
  }) {
    super(K.qrcode, u), this.width = i, this.height = n;
  }
}
class T0 extends Fu {
  /**
   * 创建一个条形码打印节点
   * @param content 条形码内容
   * @param height 高度，单位mm
   */
  constructor(u, {
    height: i = "30mm"
  }) {
    super(K.barcode, u), this.height = i;
  }
}
class Su extends Fu {
  // 线型
  constructor(i, n) {
    super(K.line, "");
    L(this, "width", "1px");
    // 线宽
    L(this, "lineType", "solid");
    this.width = i, this.lineType = n;
  }
  /**
   * 根据 border style 值创建一个线打印节点
   * @param style {Object}
   * @returns {LinePrintNodeModel}
   */
  static fromCss(i = {}) {
    let n = i.border || i["border-top"] || i["border-bottom"] || "";
    if (n)
      return Su.fromBorderStyle(n);
    let o = "1px", l = "solid";
    return i.width && i.width.endsWith("px") && (o = i.width), i["border-style"] && (l = i["border-style"]), new Su(o, l);
  }
  static fromBorderStyle(i) {
    let n = i.split(" "), o = "1px", l = "solid";
    return n.forEach((f, s) => {
      f.endsWith("px") ? o = f : (f === "solid" || f === "dashed" || f === "dotted") && (l = f);
    }), new Su(o, l);
  }
}
class K {
}
L(K, "text", "text"), L(K, "textSpan", "textSpan"), L(K, "image", "image"), L(K, "qrcode", "qrcode"), L(K, "barcode", "barcode"), L(K, "line", "line");
class Cu {
}
L(Cu, "normal", "normal"), L(Cu, "italic", "italic");
class Nu {
  // 删除线
}
L(Nu, "none", "none"), // 无
L(Nu, "underline", "underline"), // 下划线
L(Nu, "lineThrough", "line-through");
function B0(r) {
  return A0(r) || {};
}
function _0(r) {
  const u = [
    "body",
    "p",
    "span",
    "img",
    "qr-code",
    "bar-code",
    "b",
    "strong",
    "br",
    "table",
    "tr",
    "th",
    "td",
    "line"
  ];
  if (u.indexOf(r) === -1)
    throw new I0(`Unsupported tag name: [${r}]. only support ${u.join(", ")}`);
}
function N0(r) {
  const u = ["span", "b", "strong"], i = ["body", "p", "img", "qr-code", "bar-code", "br", "table", "tr", "th", "td", "line"];
  return u.indexOf(r) !== -1 ? xu.Inline : (i.indexOf(r) !== -1, xu.Block);
}
function Zu(r, u) {
  if (r === u || u == null)
    return r;
  if (r == null)
    return u;
  let i = {};
  for (let n in u)
    i[n] = u[n];
  for (let n in r)
    i[n] = r[n];
  return i;
}
function L0(r) {
  return r.charCodeAt ? r.charCodeAt(0) < 256 : /[\x00-\xff]/g.test(r);
}
function ie(r, u) {
  if (r == null || r === "")
    return 0;
  let i = L0(r) ? 1 : 2;
  if (u["font-size"])
    try {
      i *= parseInt(u["font-size"]);
    } catch (n) {
      console.error(`getCharWidth parseInt error, font-size:${u["font-size"]}, `, n);
    }
  if (u["scale-width"])
    try {
      i *= parseInt(u["scale-width"]);
    } catch (n) {
      console.error(`getCharWidth parseInt error, scale-width:${u["scale-width"]}, `, n);
    }
  return i;
}
function q0(r, u) {
  let i = 0;
  for (let n = 0; n < r.length; n++)
    i += ie(r[n], u);
  return i;
}
function F0(r) {
  let u = 0;
  for (let i = 0; i < r.content.length; i++)
    u += ie(r.content[i], {
      "font-size": r.fontSize,
      "scale-width": r.scaleWidth
    });
  return u;
}
function ye(r) {
  let u = 0;
  for (let i of r.content)
    u += F0(i);
  return u;
}
function Wu(r) {
  return new pu(" ".repeat(r));
}
function k0(r) {
  let u = Array.from(r), i = [], n = [];
  for (let s = 0; s < u.length; s++)
    u[s] === "auto" ? n.push(s) : i.push(u[s]);
  let o = i.reduce((s, m) => s + m, 0), l;
  n.length > 0 && (l = 1 / n.length);
  let f = 1 - o;
  for (const s of n)
    u[s] = parseFloat((f * l).toFixed(2));
  return u;
}
class At {
  /**
   * 排版参数
   * @param {number} width 有效打印宽度，单位mm
   * @param {number} rowCharCount 每行字母数，汉字算两个字符
   * @param {number} dpi 打印机dpi
   */
  constructor({ width: u = 48, rowCharCount: i = 32, dpi: n = 203 } = {}) {
    this.width = u, this.rowCharCount = i, this.dpi = n;
  }
}
const R0 = ["b", "strong"];
class D0 {
  /**
   *
   @param {TypographyOptions} options 排版参数@param {ElementNodeModel} ast 解析后的 AST 树
   */
  constructor(u) {
    this.options = u;
  }
  /**
   * 执行排版
   * @param {ElementNodeModel} ast 解析后的 AST 树
   * @return {Array<PrintNodeModel>} 排版后的 AST 树
   */
  layout(u) {
    const i = new Yu(this.options.rowCharCount);
    return this.layoutNode(u, i, null), i.result.filter((n) => n instanceof Eu ? n.content.length > 0 || n.isBr : !0);
  }
  /**
   * 排版节点
   * @param {NodeModel} nodeModel 节点模型
   * @param {LayoutContext} context 上下文
   * @param {ElementNodeModel} parent 父节点
   */
  layoutNode(u, i, n) {
    if (u instanceof Gu) {
      let o = !1;
      if (n && n instanceof Gu && (u.style = Zu(u.style, n.style)), R0.includes(u.tag) && (u.style["font-weight"] = "600"), u.tag === "img")
        this.createImagePrint(u, i);
      else if (u.tag === "qr-code")
        this.createQrcodePrint(u, i);
      else if (u.tag === "bar-code")
        this.createBarcodePrint(u, i);
      else if (u.tag === "br")
        this.createTextPrint(u, i, !0);
      else if (u.tag === "line")
        this.createLinePrint(u, i);
      else if (u.tag === "table")
        this.layoutTable(u, i, n);
      else if (u.display === xu.Block && (this.createTextPrint(u, i), o = !0), u.children) {
        for (let l of u.children)
          this.layoutNode(l, i, u);
        o && (i.current = null);
      }
    } else
      u instanceof _e && this.layoutText(u, i, n);
  }
  /**
   * 排版文本节点
   * @param {TextNodeModel} textNode 文本节点
   * @param {Object} context 上下文
   * @param {ElementNodeModel} parent 父节点
   */
  layoutText(u, i, n) {
    i.current == null && this.createTextPrint(n, i);
    let o = n.style, l = u.text, f = pu.fromCss(o);
    for (; l.length > 0; ) {
      let s = l[0];
      const m = ie(s, o);
      if (i.charBalance < m) {
        f.content.length > 0 && (i.current.content.push(f), f = pu.fromCss(o));
        let w = new Eu("", {
          align: i.current.align
        });
        i.pushNode(w), i.current = w;
      }
      if (i.charBalance >= m)
        f.content = f.content + s, i.charBalance = i.charBalance - m, l = l.slice(1);
      else
        break;
    }
    f.content.length > 0 && i.current.content.push(f);
  }
  /**
   * 排版表格节点，表格的列数根据第一行的 td/th 的数量来确定。宽度也一样根据第一行决定。
   * @param {ElementNodeModel} nodeModel 节点模型
   * @param {LayoutContext} context 上下文
   * @param {ElementNodeModel} parent 父节点
   */
  layoutTable(u, i, n) {
    const o = this.allocateFirstRowSpace(u), l = [], f = u.style["text-align"] || "left", s = (m, w) => {
      let I = [], y = 0, q = m.children.filter((B) => B.tag === "td" || B.tag === "th");
      m.style["border-top"] && l.push(Su.fromBorderStyle(m.style["border-top"]));
      for (let B = 0; B < q.length; B++) {
        let v = q[B];
        if (B >= o.length)
          break;
        v.style = Zu(v.style, m.style);
        let S = this.options.rowCharCount * o[B];
        S = Math.floor(S);
        let C = new Yu(S);
        this.layoutNode(v, C, w), C.result.forEach((H) => {
          if (!(H instanceof Eu))
            return;
          H.align = f;
          let M = ye(H);
          if (!(M >= S)) {
            if (M < S && f === "left") {
              let J = Wu(S - M);
              H.content.push(J);
            } else if (M < S && f === "right") {
              let J = Wu(S - M);
              H.content.unshift(J);
            } else if (M < S && f === "center") {
              let J = S - M, gu = Math.floor(J / 2), uu = Wu(gu);
              H.content.unshift(uu);
              let wu = Wu(J - gu);
              H.content.push(wu);
            }
          }
        }), I.push(C.result), y = Math.max(y, C.result.length);
      }
      for (let B = 0; B < y; B++) {
        let v = new Eu([], { align: "left" });
        for (let S = 0; S < I.length; S++) {
          let H = I[S][B];
          if (H)
            H.content.forEach((M) => {
              v.content.push(M);
            });
          else {
            let M = this.options.rowCharCount * o[S];
            M = Math.floor(M);
            let J = new pu(" ".repeat(M));
            v.content.push(J);
          }
        }
        l.push(v);
      }
      m.style["border-bottom"] && l.push(Su.fromBorderStyle(m.style["border-bottom"]));
    };
    for (let m of u.children)
      m.style = Zu(m.style, u.style), m.tag === "tr" && s(m, u);
    i.result.push(...l);
  }
  /**
   * 分配行空间
   * @param {ElementNodeModel} nodeModel 节点模型
   * @returns {Array<number>} 行空间
   */
  allocateFirstRowSpace(u) {
    let i = [];
    for (let n of u.children)
      if (n.tag === "tr") {
        for (let o of n.children)
          if (o.tag === "td" || o.tag === "th") {
            let l = o.attrs.width || o.style.width;
            l && l.endsWith("%") ? i.push(parseFloat(l) / 100) : i.push("auto");
          }
        break;
      }
    return k0(i);
  }
  /**
   * 创建文本打印节点
   * @param {ElementNodeModel} nodeModel 节点模型
   * @param {LayoutContext} context 上下文
   * @param {boolean} isBr 是否是 br 节点
   */
  createTextPrint(u, i, n = !1) {
    let o = i.current;
    o && o instanceof Eu && o.content.length === 0 && !n && i.result.pop();
    let l = new Eu("", {
      align: u.style["text-align"],
      isBr: n
    });
    i.pushNode(l), i.current = l;
  }
  /**
   * 创建条码打印节点, 默认高度20mm
   * @param {ElementNodeModel} nodeModel 节点模型
   * @param {LayoutContext} context 上下文
   */
  createBarcodePrint(u, i) {
    let n = u.attrs.value;
    if (n == null)
      return;
    let o = u.attrs.height || u.style.height;
    i.pushNode(new T0(
      n,
      { height: (this.getMM(o) || 20) + "mm" }
    ));
  }
  /**
   * 创建二维码打印节点
   * @param {ElementNodeModel} nodeModel 节点模型
   * @param {LayoutContext} context 上下文
   */
  createQrcodePrint(u, i) {
    let n = u.attrs.value;
    if (n == null)
      return null;
    let o = u.attrs.width || u.style.width, l = u.attrs.height || u.style.height, { width: f, height: s } = this.getSafeWH(o, l);
    this.getMM(s) === 0 && (s = f), i.pushNode(new v0(n, { width: f, height: s }));
  }
  /**
   * 创建图片打印节点
   * @param {ElementNodeModel} nodeModel 节点模型
   * @param {LayoutContext} context 上下文
   */
  createImagePrint(u, i) {
    let n = u.attrs.src;
    if (n == null)
      return null;
    let o = u.attrs.width || u.style.width, l = u.attrs.height || u.style.height;
    i.pushNode(new S0(n, this.getSafeWH(o, l)));
  }
  /**
   * 创建分割线打印节点，如果没传自定义内容，则使用 border 样式。否则打印自定义内容
   * @param nodeModel {ElementNodeModel} line 节点
   * @param context {LayoutContext} 上下文
   */
  createLinePrint(u, i) {
    if (u.children.length === 0 && u.attrs.char == null) {
      i.pushNode(Su.fromCss(u.style));
      return;
    }
    let n = new Yu(this.options.rowCharCount);
    for (let f of u.children)
      this.layoutNode(f, n, u);
    n.result = n.result.filter((f) => f.type === Pu.Text);
    let o = n.result[0];
    o == null && (o = new Eu([], { align: "center" }));
    let l = ye(o);
    if (l < this.options.rowCharCount) {
      let f = u.attrs.char || "-", s = q0(f, u.style), m = this.options.rowCharCount - l, w = Math.floor(m / s), I = Math.floor(w / 2), y = w - I;
      o.content.unshift(pu.fromCss(u.style, f.repeat(I))), o.content.push(pu.fromCss(u.style, f.repeat(y)));
    }
    i.pushNode(o);
  }
  /**
   * 获取安全的宽高，如果宽度超出了打印机的宽度，就缩小宽度，高度也按比例缩小
   * @param width {string|number} 样式值，例如 100px 100pt 100mm 100% 100rem
   * @param height {string|number} 样式值，例如 100px 100pt 100mm 100% 100rem
   * @return {{width, height}} 返回安全的宽高
   */
  getSafeWH(u, i) {
    return u = this.getMM(u, this.options.width), i = this.getMM(i), u > this.options.width && (i = i * this.options.width / u, u = this.options.width), { width: u + "mm", height: i + "mm" };
  }
  /**
   * 获取样式宽度，单位是 mm，如果不是 mm 单位，也按照 mm 计算
   * @param {string|number} value 样式值, 例如 100px 100pt 100mm 100% 100rem
   * @param {number} defaultValue 默认值
   * @returns {number} 返回数值
   */
  getMM(u, i = 0) {
    if (u == null)
      return i;
    try {
      return parseInt(u);
    } catch {
      return i;
    }
  }
}
class Yu {
  constructor(u) {
    /**
     * 一个 item 表示一行打印内容
     * @type {Array<PrintNodeModel>}
     */
    L(this, "result", []);
    L(this, "current", null);
    L(this, "charBalance", 0);
    L(this, "initCharBalance", 0);
    this.charBalance = u, this.initCharBalance = u;
  }
  pushNode(u) {
    this.result.push(u), this.charBalance = this.initCharBalance, this.current = null;
  }
}
var Ne = {}, U0 = null;
const C0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: U0
}, Symbol.toStringTag, { value: "Module" })), P0 = /* @__PURE__ */ c0(C0);
var Le = {}, qe = {}, $u = {};
$u.byteLength = V0;
$u.toByteArray = W0;
$u.fromByteArray = $0;
var ou = [], Y = [], O0 = typeof Uint8Array < "u" ? Uint8Array : Array, Ku = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var _u = 0, M0 = Ku.length; _u < M0; ++_u)
  ou[_u] = Ku[_u], Y[Ku.charCodeAt(_u)] = _u;
Y["-".charCodeAt(0)] = 62;
Y["_".charCodeAt(0)] = 63;
function Fe(r) {
  var u = r.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var i = r.indexOf("=");
  i === -1 && (i = u);
  var n = i === u ? 0 : 4 - i % 4;
  return [i, n];
}
function V0(r) {
  var u = Fe(r), i = u[0], n = u[1];
  return (i + n) * 3 / 4 - n;
}
function j0(r, u, i) {
  return (u + i) * 3 / 4 - i;
}
function W0(r) {
  var u, i = Fe(r), n = i[0], o = i[1], l = new O0(j0(r, n, o)), f = 0, s = o > 0 ? n - 4 : n, m;
  for (m = 0; m < s; m += 4)
    u = Y[r.charCodeAt(m)] << 18 | Y[r.charCodeAt(m + 1)] << 12 | Y[r.charCodeAt(m + 2)] << 6 | Y[r.charCodeAt(m + 3)], l[f++] = u >> 16 & 255, l[f++] = u >> 8 & 255, l[f++] = u & 255;
  return o === 2 && (u = Y[r.charCodeAt(m)] << 2 | Y[r.charCodeAt(m + 1)] >> 4, l[f++] = u & 255), o === 1 && (u = Y[r.charCodeAt(m)] << 10 | Y[r.charCodeAt(m + 1)] << 4 | Y[r.charCodeAt(m + 2)] >> 2, l[f++] = u >> 8 & 255, l[f++] = u & 255), l;
}
function H0(r) {
  return ou[r >> 18 & 63] + ou[r >> 12 & 63] + ou[r >> 6 & 63] + ou[r & 63];
}
function G0(r, u, i) {
  for (var n, o = [], l = u; l < i; l += 3)
    n = (r[l] << 16 & 16711680) + (r[l + 1] << 8 & 65280) + (r[l + 2] & 255), o.push(H0(n));
  return o.join("");
}
function $0(r) {
  for (var u, i = r.length, n = i % 3, o = [], l = 16383, f = 0, s = i - n; f < s; f += l)
    o.push(G0(r, f, f + l > s ? s : f + l));
  return n === 1 ? (u = r[i - 1], o.push(
    ou[u >> 2] + ou[u << 4 & 63] + "=="
  )) : n === 2 && (u = (r[i - 2] << 8) + r[i - 1], o.push(
    ou[u >> 10] + ou[u >> 4 & 63] + ou[u << 2 & 63] + "="
  )), o.join("");
}
var ae = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ae.read = function(r, u, i, n, o) {
  var l, f, s = o * 8 - n - 1, m = (1 << s) - 1, w = m >> 1, I = -7, y = i ? o - 1 : 0, q = i ? -1 : 1, B = r[u + y];
  for (y += q, l = B & (1 << -I) - 1, B >>= -I, I += s; I > 0; l = l * 256 + r[u + y], y += q, I -= 8)
    ;
  for (f = l & (1 << -I) - 1, l >>= -I, I += n; I > 0; f = f * 256 + r[u + y], y += q, I -= 8)
    ;
  if (l === 0)
    l = 1 - w;
  else {
    if (l === m)
      return f ? NaN : (B ? -1 : 1) * (1 / 0);
    f = f + Math.pow(2, n), l = l - w;
  }
  return (B ? -1 : 1) * f * Math.pow(2, l - n);
};
ae.write = function(r, u, i, n, o, l) {
  var f, s, m, w = l * 8 - o - 1, I = (1 << w) - 1, y = I >> 1, q = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, B = n ? 0 : l - 1, v = n ? 1 : -1, S = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
  for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (s = isNaN(u) ? 1 : 0, f = I) : (f = Math.floor(Math.log(u) / Math.LN2), u * (m = Math.pow(2, -f)) < 1 && (f--, m *= 2), f + y >= 1 ? u += q / m : u += q * Math.pow(2, 1 - y), u * m >= 2 && (f++, m /= 2), f + y >= I ? (s = 0, f = I) : f + y >= 1 ? (s = (u * m - 1) * Math.pow(2, o), f = f + y) : (s = u * Math.pow(2, y - 1) * Math.pow(2, o), f = 0)); o >= 8; r[i + B] = s & 255, B += v, s /= 256, o -= 8)
    ;
  for (f = f << o | s, w += o; w > 0; r[i + B] = f & 255, B += v, f /= 256, w -= 8)
    ;
  r[i + B - v] |= S * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  const u = $u, i = ae, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = s, r.SlowBuffer = M, r.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  r.kMaxLength = o, s.TYPED_ARRAY_SUPPORT = l(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const a = new Uint8Array(1), e = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(a, e), a.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(a) {
    if (a > o)
      throw new RangeError('The value "' + a + '" is invalid for option "size"');
    const e = new Uint8Array(a);
    return Object.setPrototypeOf(e, s.prototype), e;
  }
  function s(a, e, t) {
    if (typeof a == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(a);
    }
    return m(a, e, t);
  }
  s.poolSize = 8192;
  function m(a, e, t) {
    if (typeof a == "string")
      return q(a, e);
    if (ArrayBuffer.isView(a))
      return v(a);
    if (a == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a
      );
    if (ru(a, ArrayBuffer) || a && ru(a.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ru(a, SharedArrayBuffer) || a && ru(a.buffer, SharedArrayBuffer)))
      return S(a, e, t);
    if (typeof a == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const c = a.valueOf && a.valueOf();
    if (c != null && c !== a)
      return s.from(c, e, t);
    const d = C(a);
    if (d)
      return d;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof a[Symbol.toPrimitive] == "function")
      return s.from(a[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a
    );
  }
  s.from = function(a, e, t) {
    return m(a, e, t);
  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
  function w(a) {
    if (typeof a != "number")
      throw new TypeError('"size" argument must be of type number');
    if (a < 0)
      throw new RangeError('The value "' + a + '" is invalid for option "size"');
  }
  function I(a, e, t) {
    return w(a), a <= 0 ? f(a) : e !== void 0 ? typeof t == "string" ? f(a).fill(e, t) : f(a).fill(e) : f(a);
  }
  s.alloc = function(a, e, t) {
    return I(a, e, t);
  };
  function y(a) {
    return w(a), f(a < 0 ? 0 : H(a) | 0);
  }
  s.allocUnsafe = function(a) {
    return y(a);
  }, s.allocUnsafeSlow = function(a) {
    return y(a);
  };
  function q(a, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !s.isEncoding(e))
      throw new TypeError("Unknown encoding: " + e);
    const t = J(a, e) | 0;
    let c = f(t);
    const d = c.write(a, e);
    return d !== t && (c = c.slice(0, d)), c;
  }
  function B(a) {
    const e = a.length < 0 ? 0 : H(a.length) | 0, t = f(e);
    for (let c = 0; c < e; c += 1)
      t[c] = a[c] & 255;
    return t;
  }
  function v(a) {
    if (ru(a, Uint8Array)) {
      const e = new Uint8Array(a);
      return S(e.buffer, e.byteOffset, e.byteLength);
    }
    return B(a);
  }
  function S(a, e, t) {
    if (e < 0 || a.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (a.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let c;
    return e === void 0 && t === void 0 ? c = new Uint8Array(a) : t === void 0 ? c = new Uint8Array(a, e) : c = new Uint8Array(a, e, t), Object.setPrototypeOf(c, s.prototype), c;
  }
  function C(a) {
    if (s.isBuffer(a)) {
      const e = H(a.length) | 0, t = f(e);
      return t.length === 0 || a.copy(t, 0, 0, e), t;
    }
    if (a.length !== void 0)
      return typeof a.length != "number" || Qu(a.length) ? f(0) : B(a);
    if (a.type === "Buffer" && Array.isArray(a.data))
      return B(a.data);
  }
  function H(a) {
    if (a >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return a | 0;
  }
  function M(a) {
    return +a != a && (a = 0), s.alloc(+a);
  }
  s.isBuffer = function(e) {
    return e != null && e._isBuffer === !0 && e !== s.prototype;
  }, s.compare = function(e, t) {
    if (ru(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), ru(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === t)
      return 0;
    let c = e.length, d = t.length;
    for (let h = 0, p = Math.min(c, d); h < p; ++h)
      if (e[h] !== t[h]) {
        c = e[h], d = t[h];
        break;
      }
    return c < d ? -1 : d < c ? 1 : 0;
  }, s.isEncoding = function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0)
      return s.alloc(0);
    let c;
    if (t === void 0)
      for (t = 0, c = 0; c < e.length; ++c)
        t += e[c].length;
    const d = s.allocUnsafe(t);
    let h = 0;
    for (c = 0; c < e.length; ++c) {
      let p = e[c];
      if (ru(p, Uint8Array))
        h + p.length > d.length ? (s.isBuffer(p) || (p = s.from(p)), p.copy(d, h)) : Uint8Array.prototype.set.call(
          d,
          p,
          h
        );
      else if (s.isBuffer(p))
        p.copy(d, h);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      h += p.length;
    }
    return d;
  };
  function J(a, e) {
    if (s.isBuffer(a))
      return a.length;
    if (ArrayBuffer.isView(a) || ru(a, ArrayBuffer))
      return a.byteLength;
    if (typeof a != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof a
      );
    const t = a.length, c = arguments.length > 2 && arguments[2] === !0;
    if (!c && t === 0)
      return 0;
    let d = !1;
    for (; ; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Xu(a).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return se(a).length;
        default:
          if (d)
            return c ? -1 : Xu(a).length;
          e = ("" + e).toLowerCase(), d = !0;
      }
  }
  s.byteLength = J;
  function gu(a, e, t) {
    let c = !1;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
      return "";
    for (a || (a = "utf8"); ; )
      switch (a) {
        case "hex":
          return yu(this, e, t);
        case "utf8":
        case "utf-8":
          return k(this, e, t);
        case "ascii":
          return Z(this, e, t);
        case "latin1":
        case "binary":
          return fu(this, e, t);
        case "base64":
          return _(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return vu(this, e, t);
        default:
          if (c)
            throw new TypeError("Unknown encoding: " + a);
          a = (a + "").toLowerCase(), c = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function uu(a, e, t) {
    const c = a[e];
    a[e] = a[t], a[t] = c;
  }
  s.prototype.swap16 = function() {
    const e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2)
      uu(this, t, t + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4)
      uu(this, t, t + 3), uu(this, t + 1, t + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < e; t += 8)
      uu(this, t, t + 7), uu(this, t + 1, t + 6), uu(this, t + 2, t + 5), uu(this, t + 3, t + 4);
    return this;
  }, s.prototype.toString = function() {
    const e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? k(this, 0, e) : gu.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e) {
    if (!s.isBuffer(e))
      throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : s.compare(this, e) === 0;
  }, s.prototype.inspect = function() {
    let e = "";
    const t = r.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(e, t, c, d, h) {
    if (ru(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e
      );
    if (t === void 0 && (t = 0), c === void 0 && (c = e ? e.length : 0), d === void 0 && (d = 0), h === void 0 && (h = this.length), t < 0 || c > e.length || d < 0 || h > this.length)
      throw new RangeError("out of range index");
    if (d >= h && t >= c)
      return 0;
    if (d >= h)
      return -1;
    if (t >= c)
      return 1;
    if (t >>>= 0, c >>>= 0, d >>>= 0, h >>>= 0, this === e)
      return 0;
    let p = h - d, N = c - t;
    const P = Math.min(p, N), U = this.slice(d, h), O = e.slice(t, c);
    for (let R = 0; R < P; ++R)
      if (U[R] !== O[R]) {
        p = U[R], N = O[R];
        break;
      }
    return p < N ? -1 : N < p ? 1 : 0;
  };
  function wu(a, e, t, c, d) {
    if (a.length === 0)
      return -1;
    if (typeof t == "string" ? (c = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, Qu(t) && (t = d ? 0 : a.length - 1), t < 0 && (t = a.length + t), t >= a.length) {
      if (d)
        return -1;
      t = a.length - 1;
    } else if (t < 0)
      if (d)
        t = 0;
      else
        return -1;
    if (typeof e == "string" && (e = s.from(e, c)), s.isBuffer(e))
      return e.length === 0 ? -1 : ku(a, e, t, c, d);
    if (typeof e == "number")
      return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? d ? Uint8Array.prototype.indexOf.call(a, e, t) : Uint8Array.prototype.lastIndexOf.call(a, e, t) : ku(a, [e], t, c, d);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ku(a, e, t, c, d) {
    let h = 1, p = a.length, N = e.length;
    if (c !== void 0 && (c = String(c).toLowerCase(), c === "ucs2" || c === "ucs-2" || c === "utf16le" || c === "utf-16le")) {
      if (a.length < 2 || e.length < 2)
        return -1;
      h = 2, p /= 2, N /= 2, t /= 2;
    }
    function P(O, R) {
      return h === 1 ? O[R] : O.readUInt16BE(R * h);
    }
    let U;
    if (d) {
      let O = -1;
      for (U = t; U < p; U++)
        if (P(a, U) === P(e, O === -1 ? 0 : U - O)) {
          if (O === -1 && (O = U), U - O + 1 === N)
            return O * h;
        } else
          O !== -1 && (U -= U - O), O = -1;
    } else
      for (t + N > p && (t = p - N), U = t; U >= 0; U--) {
        let O = !0;
        for (let R = 0; R < N; R++)
          if (P(a, U + R) !== P(e, R)) {
            O = !1;
            break;
          }
        if (O)
          return U;
      }
    return -1;
  }
  s.prototype.includes = function(e, t, c) {
    return this.indexOf(e, t, c) !== -1;
  }, s.prototype.indexOf = function(e, t, c) {
    return wu(this, e, t, c, !0);
  }, s.prototype.lastIndexOf = function(e, t, c) {
    return wu(this, e, t, c, !1);
  };
  function V(a, e, t, c) {
    t = Number(t) || 0;
    const d = a.length - t;
    c ? (c = Number(c), c > d && (c = d)) : c = d;
    const h = e.length;
    c > h / 2 && (c = h / 2);
    let p;
    for (p = 0; p < c; ++p) {
      const N = parseInt(e.substr(p * 2, 2), 16);
      if (Qu(N))
        return p;
      a[t + p] = N;
    }
    return p;
  }
  function x(a, e, t, c) {
    return Vu(Xu(e, a.length - t), a, t, c);
  }
  function E(a, e, t, c) {
    return Vu(Ve(e), a, t, c);
  }
  function b(a, e, t, c) {
    return Vu(se(e), a, t, c);
  }
  function A(a, e, t, c) {
    return Vu(je(e, a.length - t), a, t, c);
  }
  s.prototype.write = function(e, t, c, d) {
    if (t === void 0)
      d = "utf8", c = this.length, t = 0;
    else if (c === void 0 && typeof t == "string")
      d = t, c = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(c) ? (c = c >>> 0, d === void 0 && (d = "utf8")) : (d = c, c = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const h = this.length - t;
    if ((c === void 0 || c > h) && (c = h), e.length > 0 && (c < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    d || (d = "utf8");
    let p = !1;
    for (; ; )
      switch (d) {
        case "hex":
          return V(this, e, t, c);
        case "utf8":
        case "utf-8":
          return x(this, e, t, c);
        case "ascii":
        case "latin1":
        case "binary":
          return E(this, e, t, c);
        case "base64":
          return b(this, e, t, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A(this, e, t, c);
        default:
          if (p)
            throw new TypeError("Unknown encoding: " + d);
          d = ("" + d).toLowerCase(), p = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function _(a, e, t) {
    return e === 0 && t === a.length ? u.fromByteArray(a) : u.fromByteArray(a.slice(e, t));
  }
  function k(a, e, t) {
    t = Math.min(a.length, t);
    const c = [];
    let d = e;
    for (; d < t; ) {
      const h = a[d];
      let p = null, N = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
      if (d + N <= t) {
        let P, U, O, R;
        switch (N) {
          case 1:
            h < 128 && (p = h);
            break;
          case 2:
            P = a[d + 1], (P & 192) === 128 && (R = (h & 31) << 6 | P & 63, R > 127 && (p = R));
            break;
          case 3:
            P = a[d + 1], U = a[d + 2], (P & 192) === 128 && (U & 192) === 128 && (R = (h & 15) << 12 | (P & 63) << 6 | U & 63, R > 2047 && (R < 55296 || R > 57343) && (p = R));
            break;
          case 4:
            P = a[d + 1], U = a[d + 2], O = a[d + 3], (P & 192) === 128 && (U & 192) === 128 && (O & 192) === 128 && (R = (h & 15) << 18 | (P & 63) << 12 | (U & 63) << 6 | O & 63, R > 65535 && R < 1114112 && (p = R));
        }
      }
      p === null ? (p = 65533, N = 1) : p > 65535 && (p -= 65536, c.push(p >>> 10 & 1023 | 55296), p = 56320 | p & 1023), c.push(p), d += N;
    }
    return eu(c);
  }
  const W = 4096;
  function eu(a) {
    const e = a.length;
    if (e <= W)
      return String.fromCharCode.apply(String, a);
    let t = "", c = 0;
    for (; c < e; )
      t += String.fromCharCode.apply(
        String,
        a.slice(c, c += W)
      );
    return t;
  }
  function Z(a, e, t) {
    let c = "";
    t = Math.min(a.length, t);
    for (let d = e; d < t; ++d)
      c += String.fromCharCode(a[d] & 127);
    return c;
  }
  function fu(a, e, t) {
    let c = "";
    t = Math.min(a.length, t);
    for (let d = e; d < t; ++d)
      c += String.fromCharCode(a[d]);
    return c;
  }
  function yu(a, e, t) {
    const c = a.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > c) && (t = c);
    let d = "";
    for (let h = e; h < t; ++h)
      d += We[a[h]];
    return d;
  }
  function vu(a, e, t) {
    const c = a.slice(e, t);
    let d = "";
    for (let h = 0; h < c.length - 1; h += 2)
      d += String.fromCharCode(c[h] + c[h + 1] * 256);
    return d;
  }
  s.prototype.slice = function(e, t) {
    const c = this.length;
    e = ~~e, t = t === void 0 ? c : ~~t, e < 0 ? (e += c, e < 0 && (e = 0)) : e > c && (e = c), t < 0 ? (t += c, t < 0 && (t = 0)) : t > c && (t = c), t < e && (t = e);
    const d = this.subarray(e, t);
    return Object.setPrototypeOf(d, s.prototype), d;
  };
  function D(a, e, t) {
    if (a % 1 !== 0 || a < 0)
      throw new RangeError("offset is not uint");
    if (a + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = this[e], h = 1, p = 0;
    for (; ++p < t && (h *= 256); )
      d += this[e + p] * h;
    return d;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = this[e + --t], h = 1;
    for (; t > 0 && (h *= 256); )
      d += this[e + --t] * h;
    return d;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(e, t) {
    return e = e >>> 0, t || D(e, 1, this.length), this[e];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(e, t) {
    return e = e >>> 0, t || D(e, 2, this.length), this[e] | this[e + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(e, t) {
    return e = e >>> 0, t || D(e, 2, this.length), this[e] << 8 | this[e + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  }, s.prototype.readBigUInt64LE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, h = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + c * 2 ** 24;
    return BigInt(d) + (BigInt(h) << BigInt(32));
  }), s.prototype.readBigUInt64BE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], h = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + c;
    return (BigInt(d) << BigInt(32)) + BigInt(h);
  }), s.prototype.readIntLE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = this[e], h = 1, p = 0;
    for (; ++p < t && (h *= 256); )
      d += this[e + p] * h;
    return h *= 128, d >= h && (d -= Math.pow(2, 8 * t)), d;
  }, s.prototype.readIntBE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = t, h = 1, p = this[e + --d];
    for (; d > 0 && (h *= 256); )
      p += this[e + --d] * h;
    return h *= 128, p >= h && (p -= Math.pow(2, 8 * t)), p;
  }, s.prototype.readInt8 = function(e, t) {
    return e = e >>> 0, t || D(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  }, s.prototype.readInt16LE = function(e, t) {
    e = e >>> 0, t || D(e, 2, this.length);
    const c = this[e] | this[e + 1] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, s.prototype.readInt16BE = function(e, t) {
    e = e >>> 0, t || D(e, 2, this.length);
    const c = this[e + 1] | this[e] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, s.prototype.readInt32LE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  }, s.prototype.readInt32BE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  }, s.prototype.readBigInt64LE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (c << 24);
    return (BigInt(d) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  }), s.prototype.readBigInt64BE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = (t << 24) + // Overflow
    this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(d) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + c);
  }), s.prototype.readFloatLE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), i.read(this, e, !0, 23, 4);
  }, s.prototype.readFloatBE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), i.read(this, e, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(e, t) {
    return e = e >>> 0, t || D(e, 8, this.length), i.read(this, e, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(e, t) {
    return e = e >>> 0, t || D(e, 8, this.length), i.read(this, e, !1, 52, 8);
  };
  function z(a, e, t, c, d, h) {
    if (!s.isBuffer(a))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > d || e < h)
      throw new RangeError('"value" argument is out of bounds');
    if (t + c > a.length)
      throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, c = c >>> 0, !d) {
      const N = Math.pow(2, 8 * c) - 1;
      z(this, e, t, c, N, 0);
    }
    let h = 1, p = 0;
    for (this[t] = e & 255; ++p < c && (h *= 256); )
      this[t + p] = e / h & 255;
    return t + c;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, c = c >>> 0, !d) {
      const N = Math.pow(2, 8 * c) - 1;
      z(this, e, t, c, N, 0);
    }
    let h = c - 1, p = 1;
    for (this[t + h] = e & 255; --h >= 0 && (p *= 256); )
      this[t + h] = e / p & 255;
    return t + c;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  };
  function X(a, e, t, c, d) {
    ce(e, c, d, a, t, 7);
    let h = Number(e & BigInt(4294967295));
    a[t++] = h, h = h >> 8, a[t++] = h, h = h >> 8, a[t++] = h, h = h >> 8, a[t++] = h;
    let p = Number(e >> BigInt(32) & BigInt(4294967295));
    return a[t++] = p, p = p >> 8, a[t++] = p, p = p >> 8, a[t++] = p, p = p >> 8, a[t++] = p, t;
  }
  function Ru(a, e, t, c, d) {
    ce(e, c, d, a, t, 7);
    let h = Number(e & BigInt(4294967295));
    a[t + 7] = h, h = h >> 8, a[t + 6] = h, h = h >> 8, a[t + 5] = h, h = h >> 8, a[t + 4] = h;
    let p = Number(e >> BigInt(32) & BigInt(4294967295));
    return a[t + 3] = p, p = p >> 8, a[t + 2] = p, p = p >> 8, a[t + 1] = p, p = p >> 8, a[t] = p, t + 8;
  }
  s.prototype.writeBigUInt64LE = bu(function(e, t = 0) {
    return X(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = bu(function(e, t = 0) {
    return Ru(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, !d) {
      const P = Math.pow(2, 8 * c - 1);
      z(this, e, t, c, P - 1, -P);
    }
    let h = 0, p = 1, N = 0;
    for (this[t] = e & 255; ++h < c && (p *= 256); )
      e < 0 && N === 0 && this[t + h - 1] !== 0 && (N = 1), this[t + h] = (e / p >> 0) - N & 255;
    return t + c;
  }, s.prototype.writeIntBE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, !d) {
      const P = Math.pow(2, 8 * c - 1);
      z(this, e, t, c, P - 1, -P);
    }
    let h = c - 1, p = 1, N = 0;
    for (this[t + h] = e & 255; --h >= 0 && (p *= 256); )
      e < 0 && N === 0 && this[t + h + 1] !== 0 && (N = 1), this[t + h] = (e / p >> 0) - N & 255;
    return t + c;
  }, s.prototype.writeInt8 = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
  }, s.prototype.writeInt16LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, s.prototype.writeInt16BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, s.prototype.writeInt32LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
  }, s.prototype.writeInt32BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  }, s.prototype.writeBigInt64LE = bu(function(e, t = 0) {
    return X(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = bu(function(e, t = 0) {
    return Ru(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ou(a, e, t, c, d, h) {
    if (t + c > a.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function Mu(a, e, t, c, d) {
    return e = +e, t = t >>> 0, d || Ou(a, e, t, 4), i.write(a, e, t, c, 23, 4), t + 4;
  }
  s.prototype.writeFloatLE = function(e, t, c) {
    return Mu(this, e, t, !0, c);
  }, s.prototype.writeFloatBE = function(e, t, c) {
    return Mu(this, e, t, !1, c);
  };
  function Du(a, e, t, c, d) {
    return e = +e, t = t >>> 0, d || Ou(a, e, t, 8), i.write(a, e, t, c, 52, 8), t + 8;
  }
  s.prototype.writeDoubleLE = function(e, t, c) {
    return Du(this, e, t, !0, c);
  }, s.prototype.writeDoubleBE = function(e, t, c) {
    return Du(this, e, t, !1, c);
  }, s.prototype.copy = function(e, t, c, d) {
    if (!s.isBuffer(e))
      throw new TypeError("argument should be a Buffer");
    if (c || (c = 0), !d && d !== 0 && (d = this.length), t >= e.length && (t = e.length), t || (t = 0), d > 0 && d < c && (d = c), d === c || e.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (c < 0 || c >= this.length)
      throw new RangeError("Index out of range");
    if (d < 0)
      throw new RangeError("sourceEnd out of bounds");
    d > this.length && (d = this.length), e.length - t < d - c && (d = e.length - t + c);
    const h = d - c;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, c, d) : Uint8Array.prototype.set.call(
      e,
      this.subarray(c, d),
      t
    ), h;
  }, s.prototype.fill = function(e, t, c, d) {
    if (typeof e == "string") {
      if (typeof t == "string" ? (d = t, t = 0, c = this.length) : typeof c == "string" && (d = c, c = this.length), d !== void 0 && typeof d != "string")
        throw new TypeError("encoding must be a string");
      if (typeof d == "string" && !s.isEncoding(d))
        throw new TypeError("Unknown encoding: " + d);
      if (e.length === 1) {
        const p = e.charCodeAt(0);
        (d === "utf8" && p < 128 || d === "latin1") && (e = p);
      }
    } else
      typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < c)
      throw new RangeError("Out of range index");
    if (c <= t)
      return this;
    t = t >>> 0, c = c === void 0 ? this.length : c >>> 0, e || (e = 0);
    let h;
    if (typeof e == "number")
      for (h = t; h < c; ++h)
        this[h] = e;
    else {
      const p = s.isBuffer(e) ? e : s.from(e, d), N = p.length;
      if (N === 0)
        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (h = 0; h < c - t; ++h)
        this[h + t] = p[h % N];
    }
    return this;
  };
  const tu = {};
  function zu(a, e, t) {
    tu[a] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: e.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${a}]`, this.stack, delete this.name;
      }
      get code() {
        return a;
      }
      set code(d) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: d,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${a}]: ${this.message}`;
      }
    };
  }
  zu(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(a) {
      return a ? `${a} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), zu(
    "ERR_INVALID_ARG_TYPE",
    function(a, e) {
      return `The "${a}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  ), zu(
    "ERR_OUT_OF_RANGE",
    function(a, e, t) {
      let c = `The value of "${a}" is out of range.`, d = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? d = ne(String(t)) : typeof t == "bigint" && (d = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (d = ne(d)), d += "n"), c += ` It must be ${e}. Received ${d}`, c;
    },
    RangeError
  );
  function ne(a) {
    let e = "", t = a.length;
    const c = a[0] === "-" ? 1 : 0;
    for (; t >= c + 4; t -= 3)
      e = `_${a.slice(t - 3, t)}${e}`;
    return `${a.slice(0, t)}${e}`;
  }
  function Pe(a, e, t) {
    Tu(e, "offset"), (a[e] === void 0 || a[e + t] === void 0) && Uu(e, a.length - (t + 1));
  }
  function ce(a, e, t, c, d, h) {
    if (a > t || a < e) {
      const p = typeof e == "bigint" ? "n" : "";
      let N;
      throw h > 3 ? e === 0 || e === BigInt(0) ? N = `>= 0${p} and < 2${p} ** ${(h + 1) * 8}${p}` : N = `>= -(2${p} ** ${(h + 1) * 8 - 1}${p}) and < 2 ** ${(h + 1) * 8 - 1}${p}` : N = `>= ${e}${p} and <= ${t}${p}`, new tu.ERR_OUT_OF_RANGE("value", N, a);
    }
    Pe(c, d, h);
  }
  function Tu(a, e) {
    if (typeof a != "number")
      throw new tu.ERR_INVALID_ARG_TYPE(e, "number", a);
  }
  function Uu(a, e, t) {
    throw Math.floor(a) !== a ? (Tu(a, t), new tu.ERR_OUT_OF_RANGE(t || "offset", "an integer", a)) : e < 0 ? new tu.ERR_BUFFER_OUT_OF_BOUNDS() : new tu.ERR_OUT_OF_RANGE(
      t || "offset",
      `>= ${t ? 1 : 0} and <= ${e}`,
      a
    );
  }
  const Oe = /[^+/0-9A-Za-z-_]/g;
  function Me(a) {
    if (a = a.split("=")[0], a = a.trim().replace(Oe, ""), a.length < 2)
      return "";
    for (; a.length % 4 !== 0; )
      a = a + "=";
    return a;
  }
  function Xu(a, e) {
    e = e || 1 / 0;
    let t;
    const c = a.length;
    let d = null;
    const h = [];
    for (let p = 0; p < c; ++p) {
      if (t = a.charCodeAt(p), t > 55295 && t < 57344) {
        if (!d) {
          if (t > 56319) {
            (e -= 3) > -1 && h.push(239, 191, 189);
            continue;
          } else if (p + 1 === c) {
            (e -= 3) > -1 && h.push(239, 191, 189);
            continue;
          }
          d = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && h.push(239, 191, 189), d = t;
          continue;
        }
        t = (d - 55296 << 10 | t - 56320) + 65536;
      } else
        d && (e -= 3) > -1 && h.push(239, 191, 189);
      if (d = null, t < 128) {
        if ((e -= 1) < 0)
          break;
        h.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0)
          break;
        h.push(
          t >> 6 | 192,
          t & 63 | 128
        );
      } else if (t < 65536) {
        if ((e -= 3) < 0)
          break;
        h.push(
          t >> 12 | 224,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else if (t < 1114112) {
        if ((e -= 4) < 0)
          break;
        h.push(
          t >> 18 | 240,
          t >> 12 & 63 | 128,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return h;
  }
  function Ve(a) {
    const e = [];
    for (let t = 0; t < a.length; ++t)
      e.push(a.charCodeAt(t) & 255);
    return e;
  }
  function je(a, e) {
    let t, c, d;
    const h = [];
    for (let p = 0; p < a.length && !((e -= 2) < 0); ++p)
      t = a.charCodeAt(p), c = t >> 8, d = t % 256, h.push(d), h.push(c);
    return h;
  }
  function se(a) {
    return u.toByteArray(Me(a));
  }
  function Vu(a, e, t, c) {
    let d;
    for (d = 0; d < c && !(d + t >= e.length || d >= a.length); ++d)
      e[d + t] = a[d];
    return d;
  }
  function ru(a, e) {
    return a instanceof e || a != null && a.constructor != null && a.constructor.name != null && a.constructor.name === e.name;
  }
  function Qu(a) {
    return a !== a;
  }
  const We = function() {
    const a = "0123456789abcdef", e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      const c = t * 16;
      for (let d = 0; d < 16; ++d)
        e[c + d] = a[t] + a[d];
    }
    return e;
  }();
  function bu(a) {
    return typeof BigInt > "u" ? He : a;
  }
  function He() {
    throw new Error("BigInt not supported");
  }
})(qe);
var ke = { exports: {} }, j = ke.exports = {}, au, nu;
function te() {
  throw new Error("setTimeout has not been defined");
}
function re() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? au = setTimeout : au = te;
  } catch {
    au = te;
  }
  try {
    typeof clearTimeout == "function" ? nu = clearTimeout : nu = re;
  } catch {
    nu = re;
  }
})();
function Re(r) {
  if (au === setTimeout)
    return setTimeout(r, 0);
  if ((au === te || !au) && setTimeout)
    return au = setTimeout, setTimeout(r, 0);
  try {
    return au(r, 0);
  } catch {
    try {
      return au.call(null, r, 0);
    } catch {
      return au.call(this, r, 0);
    }
  }
}
function z0(r) {
  if (nu === clearTimeout)
    return clearTimeout(r);
  if ((nu === re || !nu) && clearTimeout)
    return nu = clearTimeout, clearTimeout(r);
  try {
    return nu(r);
  } catch {
    try {
      return nu.call(null, r);
    } catch {
      return nu.call(this, r);
    }
  }
}
var lu = [], Lu = !1, Iu, Hu = -1;
function X0() {
  !Lu || !Iu || (Lu = !1, Iu.length ? lu = Iu.concat(lu) : Hu = -1, lu.length && De());
}
function De() {
  if (!Lu) {
    var r = Re(X0);
    Lu = !0;
    for (var u = lu.length; u; ) {
      for (Iu = lu, lu = []; ++Hu < u; )
        Iu && Iu[Hu].run();
      Hu = -1, u = lu.length;
    }
    Iu = null, Lu = !1, z0(r);
  }
}
j.nextTick = function(r) {
  var u = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var i = 1; i < arguments.length; i++)
      u[i - 1] = arguments[i];
  lu.push(new Ue(r, u)), lu.length === 1 && !Lu && Re(De);
};
function Ue(r, u) {
  this.fun = r, this.array = u;
}
Ue.prototype.run = function() {
  this.fun.apply(null, this.array);
};
j.title = "browser";
j.browser = !0;
j.env = {};
j.argv = [];
j.version = "";
j.versions = {};
function hu() {
}
j.on = hu;
j.addListener = hu;
j.once = hu;
j.off = hu;
j.removeListener = hu;
j.removeAllListeners = hu;
j.emit = hu;
j.prependListener = hu;
j.prependOnceListener = hu;
j.listeners = function(r) {
  return [];
};
j.binding = function(r) {
  throw new Error("process.binding is not supported");
};
j.cwd = function() {
  return "/";
};
j.chdir = function(r) {
  throw new Error("process.chdir is not supported");
};
j.umask = function() {
  return 0;
};
var Q0 = ke.exports;
(function(r) {
  Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
  const u = qe, i = Q0, n = (f) => f && f.__esModule ? f : { default: f }, o = n(i), l = globalThis || void 0 || self;
  Object.defineProperty(r, "Buffer", { enumerable: !0, get: () => u.Buffer }), Object.defineProperty(r, "process", { enumerable: !0, get: () => o.default }), r.global = l;
})(Le);
function iu(r) {
  if (typeof r != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(r));
}
function Ee(r, u) {
  for (var i = "", n = 0, o = -1, l = 0, f, s = 0; s <= r.length; ++s) {
    if (s < r.length)
      f = r.charCodeAt(s);
    else {
      if (f === 47)
        break;
      f = 47;
    }
    if (f === 47) {
      if (!(o === s - 1 || l === 1))
        if (o !== s - 1 && l === 2) {
          if (i.length < 2 || n !== 2 || i.charCodeAt(i.length - 1) !== 46 || i.charCodeAt(i.length - 2) !== 46) {
            if (i.length > 2) {
              var m = i.lastIndexOf("/");
              if (m !== i.length - 1) {
                m === -1 ? (i = "", n = 0) : (i = i.slice(0, m), n = i.length - 1 - i.lastIndexOf("/")), o = s, l = 0;
                continue;
              }
            } else if (i.length === 2 || i.length === 1) {
              i = "", n = 0, o = s, l = 0;
              continue;
            }
          }
          u && (i.length > 0 ? i += "/.." : i = "..", n = 2);
        } else
          i.length > 0 ? i += "/" + r.slice(o + 1, s) : i = r.slice(o + 1, s), n = s - o - 1;
      o = s, l = 0;
    } else
      f === 46 && l !== -1 ? ++l : l = -1;
  }
  return i;
}
function J0(r, u) {
  var i = u.dir || u.root, n = u.base || (u.name || "") + (u.ext || "");
  return i ? i === u.root ? i + n : i + r + n : n;
}
var qu = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var u = "", i = !1, n, o = arguments.length - 1; o >= -1 && !i; o--) {
      var l;
      o >= 0 ? l = arguments[o] : (n === void 0 && (n = Le.process.cwd()), l = n), iu(l), l.length !== 0 && (u = l + "/" + u, i = l.charCodeAt(0) === 47);
    }
    return u = Ee(u, !i), i ? u.length > 0 ? "/" + u : "/" : u.length > 0 ? u : ".";
  },
  normalize: function(u) {
    if (iu(u), u.length === 0)
      return ".";
    var i = u.charCodeAt(0) === 47, n = u.charCodeAt(u.length - 1) === 47;
    return u = Ee(u, !i), u.length === 0 && !i && (u = "."), u.length > 0 && n && (u += "/"), i ? "/" + u : u;
  },
  isAbsolute: function(u) {
    return iu(u), u.length > 0 && u.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var u, i = 0; i < arguments.length; ++i) {
      var n = arguments[i];
      iu(n), n.length > 0 && (u === void 0 ? u = n : u += "/" + n);
    }
    return u === void 0 ? "." : qu.normalize(u);
  },
  relative: function(u, i) {
    if (iu(u), iu(i), u === i || (u = qu.resolve(u), i = qu.resolve(i), u === i))
      return "";
    for (var n = 1; n < u.length && u.charCodeAt(n) === 47; ++n)
      ;
    for (var o = u.length, l = o - n, f = 1; f < i.length && i.charCodeAt(f) === 47; ++f)
      ;
    for (var s = i.length, m = s - f, w = l < m ? l : m, I = -1, y = 0; y <= w; ++y) {
      if (y === w) {
        if (m > w) {
          if (i.charCodeAt(f + y) === 47)
            return i.slice(f + y + 1);
          if (y === 0)
            return i.slice(f + y);
        } else
          l > w && (u.charCodeAt(n + y) === 47 ? I = y : y === 0 && (I = 0));
        break;
      }
      var q = u.charCodeAt(n + y), B = i.charCodeAt(f + y);
      if (q !== B)
        break;
      q === 47 && (I = y);
    }
    var v = "";
    for (y = n + I + 1; y <= o; ++y)
      (y === o || u.charCodeAt(y) === 47) && (v.length === 0 ? v += ".." : v += "/..");
    return v.length > 0 ? v + i.slice(f + I) : (f += I, i.charCodeAt(f) === 47 && ++f, i.slice(f));
  },
  _makeLong: function(u) {
    return u;
  },
  dirname: function(u) {
    if (iu(u), u.length === 0)
      return ".";
    for (var i = u.charCodeAt(0), n = i === 47, o = -1, l = !0, f = u.length - 1; f >= 1; --f)
      if (i = u.charCodeAt(f), i === 47) {
        if (!l) {
          o = f;
          break;
        }
      } else
        l = !1;
    return o === -1 ? n ? "/" : "." : n && o === 1 ? "//" : u.slice(0, o);
  },
  basename: function(u, i) {
    if (i !== void 0 && typeof i != "string")
      throw new TypeError('"ext" argument must be a string');
    iu(u);
    var n = 0, o = -1, l = !0, f;
    if (i !== void 0 && i.length > 0 && i.length <= u.length) {
      if (i.length === u.length && i === u)
        return "";
      var s = i.length - 1, m = -1;
      for (f = u.length - 1; f >= 0; --f) {
        var w = u.charCodeAt(f);
        if (w === 47) {
          if (!l) {
            n = f + 1;
            break;
          }
        } else
          m === -1 && (l = !1, m = f + 1), s >= 0 && (w === i.charCodeAt(s) ? --s === -1 && (o = f) : (s = -1, o = m));
      }
      return n === o ? o = m : o === -1 && (o = u.length), u.slice(n, o);
    } else {
      for (f = u.length - 1; f >= 0; --f)
        if (u.charCodeAt(f) === 47) {
          if (!l) {
            n = f + 1;
            break;
          }
        } else
          o === -1 && (l = !1, o = f + 1);
      return o === -1 ? "" : u.slice(n, o);
    }
  },
  extname: function(u) {
    iu(u);
    for (var i = -1, n = 0, o = -1, l = !0, f = 0, s = u.length - 1; s >= 0; --s) {
      var m = u.charCodeAt(s);
      if (m === 47) {
        if (!l) {
          n = s + 1;
          break;
        }
        continue;
      }
      o === -1 && (l = !1, o = s + 1), m === 46 ? i === -1 ? i = s : f !== 1 && (f = 1) : i !== -1 && (f = -1);
    }
    return i === -1 || o === -1 || // We saw a non-dot character immediately before the dot
    f === 0 || // The (right-most) trimmed path component is exactly '..'
    f === 1 && i === o - 1 && i === n + 1 ? "" : u.slice(i, o);
  },
  format: function(u) {
    if (u === null || typeof u != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof u);
    return J0("/", u);
  },
  parse: function(u) {
    iu(u);
    var i = { root: "", dir: "", base: "", ext: "", name: "" };
    if (u.length === 0)
      return i;
    var n = u.charCodeAt(0), o = n === 47, l;
    o ? (i.root = "/", l = 1) : l = 0;
    for (var f = -1, s = 0, m = -1, w = !0, I = u.length - 1, y = 0; I >= l; --I) {
      if (n = u.charCodeAt(I), n === 47) {
        if (!w) {
          s = I + 1;
          break;
        }
        continue;
      }
      m === -1 && (w = !1, m = I + 1), n === 46 ? f === -1 ? f = I : y !== 1 && (y = 1) : f !== -1 && (y = -1);
    }
    return f === -1 || m === -1 || // We saw a non-dot character immediately before the dot
    y === 0 || // The (right-most) trimmed path component is exactly '..'
    y === 1 && f === m - 1 && f === s + 1 ? m !== -1 && (s === 0 && o ? i.base = i.name = u.slice(1, m) : i.base = i.name = u.slice(s, m)) : (s === 0 && o ? (i.name = u.slice(1, f), i.base = u.slice(1, m)) : (i.name = u.slice(s, f), i.base = u.slice(s, m)), i.ext = u.slice(f, m)), s > 0 ? i.dir = u.slice(0, s - 1) : o && (i.dir = "/"), i;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
qu.posix = qu;
var Z0 = qu, Ce = {};
(function(r) {
  var u = /[|\\{}()[\]^$+*?.]/g, i = Object.prototype.hasOwnProperty, n = function(w, I) {
    return i.apply(w, [I]);
  };
  r.escapeRegExpChars = function(w) {
    return w ? String(w).replace(u, "\\$&") : "";
  };
  var o = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&#34;",
    "'": "&#39;"
  }, l = /[&<>'"]/g;
  function f(w) {
    return o[w] || w;
  }
  var s = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
  r.escapeXML = function(w) {
    return w == null ? "" : String(w).replace(l, f);
  };
  function m() {
    return Function.prototype.toString.call(this) + `;
` + s;
  }
  try {
    typeof Object.defineProperty == "function" ? Object.defineProperty(r.escapeXML, "toString", { value: m }) : r.escapeXML.toString = m;
  } catch {
    console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
  }
  r.shallowCopy = function(w, I) {
    if (I = I || {}, w != null)
      for (var y in I)
        n(I, y) && (y === "__proto__" || y === "constructor" || (w[y] = I[y]));
    return w;
  }, r.shallowCopyFromList = function(w, I, y) {
    if (y = y || [], I = I || {}, w != null)
      for (var q = 0; q < y.length; q++) {
        var B = y[q];
        if (typeof I[B] < "u") {
          if (!n(I, B) || B === "__proto__" || B === "constructor")
            continue;
          w[B] = I[B];
        }
      }
    return w;
  }, r.cache = {
    _data: {},
    set: function(w, I) {
      this._data[w] = I;
    },
    get: function(w) {
      return this._data[w];
    },
    remove: function(w) {
      delete this._data[w];
    },
    reset: function() {
      this._data = {};
    }
  }, r.hyphenToCamel = function(w) {
    return w.replace(/-[a-z]/g, function(I) {
      return I[1].toUpperCase();
    });
  }, r.createNullProtoObjWherePossible = function() {
    return typeof Object.create == "function" ? function() {
      return /* @__PURE__ */ Object.create(null);
    } : { __proto__: null } instanceof Object ? function() {
      return {};
    } : function() {
      return { __proto__: null };
    };
  }();
})(Ce);
const Y0 = "ejs", K0 = "Embedded JavaScript templates", ut = [
  "template",
  "engine",
  "ejs"
], et = "3.1.9", tt = "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)", rt = "Apache-2.0", it = {
  ejs: "./bin/cli.js"
}, at = "./lib/ejs.js", nt = "ejs.min.js", ct = "ejs.min.js", st = {
  type: "git",
  url: "git://github.com/mde/ejs.git"
}, ot = "https://github.com/mde/ejs/issues", ft = "https://github.com/mde/ejs", dt = {
  jake: "^10.8.5"
}, lt = {
  browserify: "^16.5.1",
  eslint: "^6.8.0",
  "git-directory-deploy": "^1.5.1",
  jsdoc: "^4.0.2",
  "lru-cache": "^4.0.1",
  mocha: "^10.2.0",
  "uglify-js": "^3.3.16"
}, ht = {
  node: ">=0.10.0"
}, bt = {
  test: "mocha -u tdd"
}, pt = {
  name: Y0,
  description: K0,
  keywords: ut,
  version: et,
  author: tt,
  license: rt,
  bin: it,
  main: at,
  jsdelivr: nt,
  unpkg: ct,
  repository: st,
  bugs: ot,
  homepage: ft,
  dependencies: dt,
  devDependencies: lt,
  engines: ht,
  scripts: bt
};
(function(r) {
  /**
   * @file Embedded JavaScript templating engine. {@link http://ejs.co}
   * @author Matthew Eernisse <mde@fleegix.org>
   * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
   * @project EJS
   * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
   */
  var u = P0, i = Z0, n = Ce, o = !1, l = pt.version, f = "<", s = ">", m = "%", w = "locals", I = "ejs", y = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)", q = [
    "delimiter",
    "scope",
    "context",
    "debug",
    "compileDebug",
    "client",
    "_with",
    "rmWhitespace",
    "strict",
    "filename",
    "async"
  ], B = q.concat("cache"), v = /^\uFEFF/, S = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
  r.cache = n.cache, r.fileLoader = u.readFileSync, r.localsName = w, r.promiseImpl = new Function("return this;")().Promise, r.resolveInclude = function(x, E, b) {
    var A = i.dirname, _ = i.extname, k = i.resolve, W = k(b ? E : A(E), x), eu = _(x);
    return eu || (W += ".ejs"), W;
  };
  function C(x, E) {
    var b;
    if (E.some(function(A) {
      return b = r.resolveInclude(x, A, !0), u.existsSync(b);
    }))
      return b;
  }
  function H(x, E) {
    var b, A, _ = E.views, k = /^[A-Za-z]+:\\|^\//.exec(x);
    if (k && k.length)
      x = x.replace(/^\/*/, ""), Array.isArray(E.root) ? b = C(x, E.root) : b = r.resolveInclude(x, E.root || "/", !0);
    else if (E.filename && (A = r.resolveInclude(x, E.filename), u.existsSync(A) && (b = A)), !b && Array.isArray(_) && (b = C(x, _)), !b && typeof E.includer != "function")
      throw new Error('Could not find the include file "' + E.escapeFunction(x) + '"');
    return b;
  }
  function M(x, E) {
    var b, A = x.filename, _ = arguments.length > 1;
    if (x.cache) {
      if (!A)
        throw new Error("cache option requires a filename");
      if (b = r.cache.get(A), b)
        return b;
      _ || (E = gu(A).toString().replace(v, ""));
    } else if (!_) {
      if (!A)
        throw new Error("Internal EJS error: no file name or template provided");
      E = gu(A).toString().replace(v, "");
    }
    return b = r.compile(E, x), x.cache && r.cache.set(A, b), b;
  }
  function J(x, E, b) {
    var A;
    if (b) {
      try {
        A = M(x)(E);
      } catch (_) {
        return b(_);
      }
      b(null, A);
    } else {
      if (typeof r.promiseImpl == "function")
        return new r.promiseImpl(function(_, k) {
          try {
            A = M(x)(E), _(A);
          } catch (W) {
            k(W);
          }
        });
      throw new Error("Please provide a callback function");
    }
  }
  function gu(x) {
    return r.fileLoader(x);
  }
  function uu(x, E) {
    var b = n.shallowCopy(n.createNullProtoObjWherePossible(), E);
    if (b.filename = H(x, b), typeof E.includer == "function") {
      var A = E.includer(x, b.filename);
      if (A && (A.filename && (b.filename = A.filename), A.template))
        return M(b, A.template);
    }
    return M(b);
  }
  function wu(x, E, b, A, _) {
    var k = E.split(`
`), W = Math.max(A - 3, 0), eu = Math.min(k.length, A + 3), Z = _(b), fu = k.slice(W, eu).map(function(yu, vu) {
      var D = vu + W + 1;
      return (D == A ? " >> " : "    ") + D + "| " + yu;
    }).join(`
`);
    throw x.path = Z, x.message = (Z || "ejs") + ":" + A + `
` + fu + `

` + x.message, x;
  }
  function ku(x) {
    return x.replace(/;(\s*$)/, "$1");
  }
  r.compile = function(E, b) {
    var A;
    return b && b.scope && (o || (console.warn("`scope` option is deprecated and will be removed in EJS 3"), o = !0), b.context || (b.context = b.scope), delete b.scope), A = new V(E, b), A.compile();
  }, r.render = function(x, E, b) {
    var A = E || n.createNullProtoObjWherePossible(), _ = b || n.createNullProtoObjWherePossible();
    return arguments.length == 2 && n.shallowCopyFromList(_, A, q), M(_, x)(A);
  }, r.renderFile = function() {
    var x = Array.prototype.slice.call(arguments), E = x.shift(), b, A = { filename: E }, _, k;
    return typeof arguments[arguments.length - 1] == "function" && (b = x.pop()), x.length ? (_ = x.shift(), x.length ? n.shallowCopy(A, x.pop()) : (_.settings && (_.settings.views && (A.views = _.settings.views), _.settings["view cache"] && (A.cache = !0), k = _.settings["view options"], k && n.shallowCopy(A, k)), n.shallowCopyFromList(A, _, B)), A.filename = E) : _ = n.createNullProtoObjWherePossible(), J(A, _, b);
  }, r.Template = V, r.clearCache = function() {
    r.cache.reset();
  };
  function V(x, E) {
    E = E || n.createNullProtoObjWherePossible();
    var b = n.createNullProtoObjWherePossible();
    this.templateText = x, this.mode = null, this.truncate = !1, this.currentLine = 1, this.source = "", b.client = E.client || !1, b.escapeFunction = E.escape || E.escapeFunction || n.escapeXML, b.compileDebug = E.compileDebug !== !1, b.debug = !!E.debug, b.filename = E.filename, b.openDelimiter = E.openDelimiter || r.openDelimiter || f, b.closeDelimiter = E.closeDelimiter || r.closeDelimiter || s, b.delimiter = E.delimiter || r.delimiter || m, b.strict = E.strict || !1, b.context = E.context, b.cache = E.cache || !1, b.rmWhitespace = E.rmWhitespace, b.root = E.root, b.includer = E.includer, b.outputFunctionName = E.outputFunctionName, b.localsName = E.localsName || r.localsName || w, b.views = E.views, b.async = E.async, b.destructuredLocals = E.destructuredLocals, b.legacyInclude = typeof E.legacyInclude < "u" ? !!E.legacyInclude : !0, b.strict ? b._with = !1 : b._with = typeof E._with < "u" ? E._with : !0, this.opts = b, this.regex = this.createRegex();
  }
  V.modes = {
    EVAL: "eval",
    ESCAPED: "escaped",
    RAW: "raw",
    COMMENT: "comment",
    LITERAL: "literal"
  }, V.prototype = {
    createRegex: function() {
      var x = y, E = n.escapeRegExpChars(this.opts.delimiter), b = n.escapeRegExpChars(this.opts.openDelimiter), A = n.escapeRegExpChars(this.opts.closeDelimiter);
      return x = x.replace(/%/g, E).replace(/</g, b).replace(/>/g, A), new RegExp(x);
    },
    compile: function() {
      var x, E, b = this.opts, A = "", _ = "", k = b.escapeFunction, W, eu = b.filename ? JSON.stringify(b.filename) : "undefined";
      if (!this.source) {
        if (this.generateSource(), A += `  var __output = "";
  function __append(s) { if (s !== undefined && s !== null) __output += s }
`, b.outputFunctionName) {
          if (!S.test(b.outputFunctionName))
            throw new Error("outputFunctionName is not a valid JS identifier.");
          A += "  var " + b.outputFunctionName + ` = __append;
`;
        }
        if (b.localsName && !S.test(b.localsName))
          throw new Error("localsName is not a valid JS identifier.");
        if (b.destructuredLocals && b.destructuredLocals.length) {
          for (var Z = "  var __locals = (" + b.localsName + ` || {}),
`, fu = 0; fu < b.destructuredLocals.length; fu++) {
            var yu = b.destructuredLocals[fu];
            if (!S.test(yu))
              throw new Error("destructuredLocals[" + fu + "] is not a valid JS identifier.");
            fu > 0 && (Z += `,
  `), Z += yu + " = __locals." + yu;
          }
          A += Z + `;
`;
        }
        b._with !== !1 && (A += "  with (" + b.localsName + ` || {}) {
`, _ += `  }
`), _ += `  return __output;
`, this.source = A + this.source + _;
      }
      b.compileDebug ? x = `var __line = 1
  , __lines = ` + JSON.stringify(this.templateText) + `
  , __filename = ` + eu + `;
try {
` + this.source + `} catch (e) {
  rethrow(e, __lines, __filename, __line, escapeFn);
}
` : x = this.source, b.client && (x = "escapeFn = escapeFn || " + k.toString() + `;
` + x, b.compileDebug && (x = "rethrow = rethrow || " + wu.toString() + `;
` + x)), b.strict && (x = `"use strict";
` + x), b.debug && console.log(x), b.compileDebug && b.filename && (x = x + `
//# sourceURL=` + eu + `
`);
      try {
        if (b.async)
          try {
            W = new Function("return (async function(){}).constructor;")();
          } catch (X) {
            throw X instanceof SyntaxError ? new Error("This environment does not support async/await") : X;
          }
        else
          W = Function;
        E = new W(b.localsName + ", escapeFn, include, rethrow", x);
      } catch (X) {
        throw X instanceof SyntaxError && (b.filename && (X.message += " in " + b.filename), X.message += ` while compiling ejs

`, X.message += `If the above error is not helpful, you may want to try EJS-Lint:
`, X.message += "https://github.com/RyanZim/EJS-Lint", b.async || (X.message += `
`, X.message += "Or, if you meant to create an async function, pass `async: true` as an option.")), X;
      }
      var vu = b.client ? E : function(Ru) {
        var Ou = function(Mu, Du) {
          var tu = n.shallowCopy(n.createNullProtoObjWherePossible(), Ru);
          return Du && (tu = n.shallowCopy(tu, Du)), uu(Mu, b)(tu);
        };
        return E.apply(
          b.context,
          [Ru || n.createNullProtoObjWherePossible(), k, Ou, wu]
        );
      };
      if (b.filename && typeof Object.defineProperty == "function") {
        var D = b.filename, z = i.basename(D, i.extname(D));
        try {
          Object.defineProperty(vu, "name", {
            value: z,
            writable: !1,
            enumerable: !1,
            configurable: !0
          });
        } catch {
        }
      }
      return vu;
    },
    generateSource: function() {
      var x = this.opts;
      x.rmWhitespace && (this.templateText = this.templateText.replace(/[\r\n]+/g, `
`).replace(/^\s+|\s+$/gm, "")), this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
      var E = this, b = this.parseTemplateText(), A = this.opts.delimiter, _ = this.opts.openDelimiter, k = this.opts.closeDelimiter;
      b && b.length && b.forEach(function(W, eu) {
        var Z;
        if (W.indexOf(_ + A) === 0 && W.indexOf(_ + A + A) !== 0 && (Z = b[eu + 2], !(Z == A + k || Z == "-" + A + k || Z == "_" + A + k)))
          throw new Error('Could not find matching close tag for "' + W + '".');
        E.scanLine(W);
      });
    },
    parseTemplateText: function() {
      for (var x = this.templateText, E = this.regex, b = E.exec(x), A = [], _; b; )
        _ = b.index, _ !== 0 && (A.push(x.substring(0, _)), x = x.slice(_)), A.push(b[0]), x = x.slice(b[0].length), b = E.exec(x);
      return x && A.push(x), A;
    },
    _addOutput: function(x) {
      if (this.truncate && (x = x.replace(/^(?:\r\n|\r|\n)/, ""), this.truncate = !1), !x)
        return x;
      x = x.replace(/\\/g, "\\\\"), x = x.replace(/\n/g, "\\n"), x = x.replace(/\r/g, "\\r"), x = x.replace(/"/g, '\\"'), this.source += '    ; __append("' + x + `")
`;
    },
    scanLine: function(x) {
      var E = this, b = this.opts.delimiter, A = this.opts.openDelimiter, _ = this.opts.closeDelimiter, k = 0;
      switch (k = x.split(`
`).length - 1, x) {
        case A + b:
        case A + b + "_":
          this.mode = V.modes.EVAL;
          break;
        case A + b + "=":
          this.mode = V.modes.ESCAPED;
          break;
        case A + b + "-":
          this.mode = V.modes.RAW;
          break;
        case A + b + "#":
          this.mode = V.modes.COMMENT;
          break;
        case A + b + b:
          this.mode = V.modes.LITERAL, this.source += '    ; __append("' + x.replace(A + b + b, A + b) + `")
`;
          break;
        case b + b + _:
          this.mode = V.modes.LITERAL, this.source += '    ; __append("' + x.replace(b + b + _, b + _) + `")
`;
          break;
        case b + _:
        case "-" + b + _:
        case "_" + b + _:
          this.mode == V.modes.LITERAL && this._addOutput(x), this.mode = null, this.truncate = x.indexOf("-") === 0 || x.indexOf("_") === 0;
          break;
        default:
          if (this.mode) {
            switch (this.mode) {
              case V.modes.EVAL:
              case V.modes.ESCAPED:
              case V.modes.RAW:
                x.lastIndexOf("//") > x.lastIndexOf(`
`) && (x += `
`);
            }
            switch (this.mode) {
              case V.modes.EVAL:
                this.source += "    ; " + x + `
`;
                break;
              case V.modes.ESCAPED:
                this.source += "    ; __append(escapeFn(" + ku(x) + `))
`;
                break;
              case V.modes.RAW:
                this.source += "    ; __append(" + ku(x) + `)
`;
                break;
              case V.modes.COMMENT:
                break;
              case V.modes.LITERAL:
                this._addOutput(x);
                break;
            }
          } else
            this._addOutput(x);
      }
      E.opts.compileDebug && k && (this.currentLine += k, this.source += "    ; __line = " + this.currentLine + `
`);
    }
  }, r.escapeXML = n.escapeXML, r.__express = r.renderFile, r.VERSION = l, r.name = I, typeof window < "u" && (window.ejs = r);
})(Ne);
const mt = /* @__PURE__ */ n0(Ne);
function xt(r, u) {
  let i = u == null || u === "" ? {} : JSON.parse(u);
  return mt.render(r, i, {
    rmWhitespace: !0
  });
}
function gt(r) {
  let u = new Gu("root"), i = [];
  const n = new a0({
    onopentag(o, l) {
      _0(o);
      let f = B0(l.style), s = N0(o), m = new Gu(o, {
        attrs: l,
        style: f,
        display: s
      });
      u.children.push(m), i.push(u), u = m;
    },
    ontext(o) {
      o = o.replace(/[\r\n]/g, ""), u.children.push(new _e(o));
    },
    onclosetag(o) {
      u = i.pop();
    }
  });
  return n.write(r), n.end(), u;
}
function wt(r, u) {
  return new D0(u).layout(r);
}
function St(r, u, i) {
  let n = xt(r, u), o = gt(n);
  return wt(o, i);
}
export {
  T0 as BarcodePrintNodeModel,
  Cu as FontStyle,
  S0 as ImagePrintNodeModel,
  Et as LayoutError,
  Su as LinePrintNodeModel,
  I0 as ParseError,
  Fu as PrintNodeModel,
  K as PrintType,
  v0 as QRCodePrintNodeModel,
  pu as TextChildPrintNodeModel,
  Nu as TextDecorationLine,
  Eu as TextPrintNodeModel,
  At as TypographyOptions,
  St as compilePrintNodes,
  gt as htmlParseAST,
  xt as renderTmp,
  wt as typographyAST
};
