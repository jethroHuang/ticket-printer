var Ge = Object.defineProperty;
var $e = (r, u, i) => u in r ? Ge(r, u, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[u] = i;
var L = (r, u, i) => ($e(r, typeof u != "symbol" ? u + "" : u, i), i);
const Ae = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((r) => r.charCodeAt(0))
), Ie = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((r) => r.charCodeAt(0))
);
var Ju;
const ze = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), ue = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Ju = String.fromCodePoint) !== null && Ju !== void 0 ? Ju : function(r) {
    let u = "";
    return r > 65535 && (r -= 65536, u += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), u += String.fromCharCode(r), u;
  }
);
function Xe(r) {
  var u;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (u = ze.get(r)) !== null && u !== void 0 ? u : r;
}
var $;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})($ || ($ = {}));
const Qe = 32;
var mu;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(mu || (mu = {}));
function ee(r) {
  return r >= $.ZERO && r <= $.NINE;
}
function Je(r) {
  return r >= $.UPPER_A && r <= $.UPPER_F || r >= $.LOWER_A && r <= $.LOWER_F;
}
function Ze(r) {
  return r >= $.UPPER_A && r <= $.UPPER_Z || r >= $.LOWER_A && r <= $.LOWER_Z || ee(r);
}
function Ye(r) {
  return r === $.EQUALS || Ze(r);
}
var G;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(G || (G = {}));
var cu;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(cu || (cu = {}));
class Se {
  constructor(u, i, n) {
    this.decodeTree = u, this.emitCodePoint = i, this.errors = n, this.state = G.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = cu.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(u) {
    this.decodeMode = u, this.state = G.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(u, i) {
    switch (this.state) {
      case G.EntityStart:
        return u.charCodeAt(i) === $.NUM ? (this.state = G.NumericStart, this.consumed += 1, this.stateNumericStart(u, i + 1)) : (this.state = G.NamedEntity, this.stateNamedEntity(u, i));
      case G.NumericStart:
        return this.stateNumericStart(u, i);
      case G.NumericDecimal:
        return this.stateNumericDecimal(u, i);
      case G.NumericHex:
        return this.stateNumericHex(u, i);
      case G.NamedEntity:
        return this.stateNamedEntity(u, i);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(u, i) {
    return i >= u.length ? -1 : (u.charCodeAt(i) | Qe) === $.LOWER_X ? (this.state = G.NumericHex, this.consumed += 1, this.stateNumericHex(u, i + 1)) : (this.state = G.NumericDecimal, this.stateNumericDecimal(u, i));
  }
  addToNumericResult(u, i, n, o) {
    if (i !== n) {
      const l = n - i;
      this.result = this.result * Math.pow(o, l) + parseInt(u.substr(i, l), o), this.consumed += l;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(u, i) {
    const n = i;
    for (; i < u.length; ) {
      const o = u.charCodeAt(i);
      if (ee(o) || Je(o))
        i += 1;
      else
        return this.addToNumericResult(u, n, i, 16), this.emitNumericEntity(o, 3);
    }
    return this.addToNumericResult(u, n, i, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(u, i) {
    const n = i;
    for (; i < u.length; ) {
      const o = u.charCodeAt(i);
      if (ee(o))
        i += 1;
      else
        return this.addToNumericResult(u, n, i, 10), this.emitNumericEntity(o, 2);
    }
    return this.addToNumericResult(u, n, i, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(u, i) {
    var n;
    if (this.consumed <= i)
      return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (u === $.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === cu.Strict)
      return 0;
    return this.emitCodePoint(Xe(this.result), this.consumed), this.errors && (u !== $.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(u, i) {
    const { decodeTree: n } = this;
    let o = n[this.treeIndex], l = (o & mu.VALUE_LENGTH) >> 14;
    for (; i < u.length; i++, this.excess++) {
      const f = u.charCodeAt(i);
      if (this.treeIndex = Ke(n, o, this.treeIndex + Math.max(1, l), f), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === cu.Attribute && // We shouldn't have consumed any characters after the entity,
        (l === 0 || // And there should be no invalid characters.
        Ye(f)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (o = n[this.treeIndex], l = (o & mu.VALUE_LENGTH) >> 14, l !== 0) {
        if (f === $.SEMI)
          return this.emitNamedEntityData(this.treeIndex, l, this.consumed + this.excess);
        this.decodeMode !== cu.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var u;
    const { result: i, decodeTree: n } = this, o = (n[i] & mu.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(i, o, this.consumed), (u = this.errors) === null || u === void 0 || u.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(u, i, n) {
    const { decodeTree: o } = this;
    return this.emitCodePoint(i === 1 ? o[u] & ~mu.VALUE_LENGTH : o[u + 1], n), i === 3 && this.emitCodePoint(o[u + 2], n), n;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var u;
    switch (this.state) {
      case G.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== cu.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case G.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case G.NumericHex:
        return this.emitNumericEntity(0, 3);
      case G.NumericStart:
        return (u = this.errors) === null || u === void 0 || u.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case G.EntityStart:
        return 0;
    }
  }
}
function ve(r) {
  let u = "";
  const i = new Se(r, (n) => u += ue(n));
  return function(o, l) {
    let f = 0, s = 0;
    for (; (s = o.indexOf("&", s)) >= 0; ) {
      u += o.slice(f, s), i.startEntity(l);
      const w = i.write(
        o,
        // Skip the "&"
        s + 1
      );
      if (w < 0) {
        f = s + i.end();
        break;
      }
      f = s + w, s = w === 0 ? f + 1 : f;
    }
    const m = u + o.slice(f);
    return u = "", m;
  };
}
function Ke(r, u, i, n) {
  const o = (u & mu.BRANCH_LENGTH) >> 7, l = u & mu.JUMP_TABLE;
  if (o === 0)
    return l !== 0 && n === l ? i : -1;
  if (l) {
    const m = n - l;
    return m < 0 || m >= o ? -1 : r[i + m] - 1;
  }
  let f = i, s = f + o - 1;
  for (; f <= s; ) {
    const m = f + s >>> 1, w = r[m];
    if (w < n)
      f = m + 1;
    else if (w > n)
      s = m - 1;
    else
      return r[m + o];
  }
  return -1;
}
ve(Ae);
ve(Ie);
var T;
(function(r) {
  r[r.Tab = 9] = "Tab", r[r.NewLine = 10] = "NewLine", r[r.FormFeed = 12] = "FormFeed", r[r.CarriageReturn = 13] = "CarriageReturn", r[r.Space = 32] = "Space", r[r.ExclamationMark = 33] = "ExclamationMark", r[r.Number = 35] = "Number", r[r.Amp = 38] = "Amp", r[r.SingleQuote = 39] = "SingleQuote", r[r.DoubleQuote = 34] = "DoubleQuote", r[r.Dash = 45] = "Dash", r[r.Slash = 47] = "Slash", r[r.Zero = 48] = "Zero", r[r.Nine = 57] = "Nine", r[r.Semi = 59] = "Semi", r[r.Lt = 60] = "Lt", r[r.Eq = 61] = "Eq", r[r.Gt = 62] = "Gt", r[r.Questionmark = 63] = "Questionmark", r[r.UpperA = 65] = "UpperA", r[r.LowerA = 97] = "LowerA", r[r.UpperF = 70] = "UpperF", r[r.LowerF = 102] = "LowerF", r[r.UpperZ = 90] = "UpperZ", r[r.LowerZ = 122] = "LowerZ", r[r.LowerX = 120] = "LowerX", r[r.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(T || (T = {}));
var g;
(function(r) {
  r[r.Text = 1] = "Text", r[r.BeforeTagName = 2] = "BeforeTagName", r[r.InTagName = 3] = "InTagName", r[r.InSelfClosingTag = 4] = "InSelfClosingTag", r[r.BeforeClosingTagName = 5] = "BeforeClosingTagName", r[r.InClosingTagName = 6] = "InClosingTagName", r[r.AfterClosingTagName = 7] = "AfterClosingTagName", r[r.BeforeAttributeName = 8] = "BeforeAttributeName", r[r.InAttributeName = 9] = "InAttributeName", r[r.AfterAttributeName = 10] = "AfterAttributeName", r[r.BeforeAttributeValue = 11] = "BeforeAttributeValue", r[r.InAttributeValueDq = 12] = "InAttributeValueDq", r[r.InAttributeValueSq = 13] = "InAttributeValueSq", r[r.InAttributeValueNq = 14] = "InAttributeValueNq", r[r.BeforeDeclaration = 15] = "BeforeDeclaration", r[r.InDeclaration = 16] = "InDeclaration", r[r.InProcessingInstruction = 17] = "InProcessingInstruction", r[r.BeforeComment = 18] = "BeforeComment", r[r.CDATASequence = 19] = "CDATASequence", r[r.InSpecialComment = 20] = "InSpecialComment", r[r.InCommentLike = 21] = "InCommentLike", r[r.BeforeSpecialS = 22] = "BeforeSpecialS", r[r.SpecialStartSequence = 23] = "SpecialStartSequence", r[r.InSpecialTag = 24] = "InSpecialTag", r[r.InEntity = 25] = "InEntity";
})(g || (g = {}));
function du(r) {
  return r === T.Space || r === T.NewLine || r === T.Tab || r === T.FormFeed || r === T.CarriageReturn;
}
function ju(r) {
  return r === T.Slash || r === T.Gt || du(r);
}
function u0(r) {
  return r >= T.LowerA && r <= T.LowerZ || r >= T.UpperA && r <= T.UpperZ;
}
var su;
(function(r) {
  r[r.NoValue = 0] = "NoValue", r[r.Unquoted = 1] = "Unquoted", r[r.Single = 2] = "Single", r[r.Double = 3] = "Double";
})(su || (su = {}));
const Q = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
class e0 {
  constructor({ xmlMode: u = !1, decodeEntities: i = !0 }, n) {
    this.cbs = n, this.state = g.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = g.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = u, this.decodeEntities = i, this.entityDecoder = new Se(u ? Ie : Ae, (o, l) => this.emitCodePoint(o, l));
  }
  reset() {
    this.state = g.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = g.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
  }
  write(u) {
    this.offset += this.buffer.length, this.buffer = u, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = !1;
  }
  resume() {
    this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(u) {
    u === T.Lt || !this.decodeEntities && this.fastForwardTo(T.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = g.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && u === T.Amp && this.startEntity();
  }
  stateSpecialStartSequence(u) {
    const i = this.sequenceIndex === this.currentSequence.length;
    if (!(i ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      ju(u)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (u | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = !1;
    else if (!i) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = g.InTagName, this.stateInTagName(u);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(u) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (u === T.Gt || du(u)) {
        const i = this.index - this.currentSequence.length;
        if (this.sectionStart < i) {
          const n = this.index;
          this.index = i, this.cbs.ontext(this.sectionStart, i), this.index = n;
        }
        this.isSpecial = !1, this.sectionStart = i + 2, this.stateInClosingTagName(u);
        return;
      }
      this.sequenceIndex = 0;
    }
    (u | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === Q.TitleEnd ? this.decodeEntities && u === T.Amp && this.startEntity() : this.fastForwardTo(T.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(u === T.Lt);
  }
  stateCDATASequence(u) {
    u === Q.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === Q.Cdata.length && (this.state = g.InCommentLike, this.currentSequence = Q.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = g.InDeclaration, this.stateInDeclaration(u));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(u) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === u)
        return !0;
    return this.index = this.buffer.length + this.offset - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(u) {
    u === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === Q.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = g.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : u !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(u) {
    return this.xmlMode ? !ju(u) : u0(u);
  }
  startSpecial(u, i) {
    this.isSpecial = !0, this.currentSequence = u, this.sequenceIndex = i, this.state = g.SpecialStartSequence;
  }
  stateBeforeTagName(u) {
    if (u === T.ExclamationMark)
      this.state = g.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (u === T.Questionmark)
      this.state = g.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(u)) {
      const i = u | 32;
      this.sectionStart = this.index, !this.xmlMode && i === Q.TitleEnd[2] ? this.startSpecial(Q.TitleEnd, 3) : this.state = !this.xmlMode && i === Q.ScriptEnd[2] ? g.BeforeSpecialS : g.InTagName;
    } else
      u === T.Slash ? this.state = g.BeforeClosingTagName : (this.state = g.Text, this.stateText(u));
  }
  stateInTagName(u) {
    ju(u) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u));
  }
  stateBeforeClosingTagName(u) {
    du(u) || (u === T.Gt ? this.state = g.Text : (this.state = this.isTagStartChar(u) ? g.InClosingTagName : g.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(u) {
    (u === T.Gt || du(u)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = g.AfterClosingTagName, this.stateAfterClosingTagName(u));
  }
  stateAfterClosingTagName(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(u) {
    u === T.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = g.InSpecialTag, this.sequenceIndex = 0) : this.state = g.Text, this.sectionStart = this.index + 1) : u === T.Slash ? this.state = g.InSelfClosingTag : du(u) || (this.state = g.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(u) {
    u === T.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = g.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : du(u) || (this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u));
  }
  stateInAttributeName(u) {
    (u === T.Eq || ju(u)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = g.AfterAttributeName, this.stateAfterAttributeName(u));
  }
  stateAfterAttributeName(u) {
    u === T.Eq ? this.state = g.BeforeAttributeValue : u === T.Slash || u === T.Gt ? (this.cbs.onattribend(su.NoValue, this.index), this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u)) : du(u) || (this.cbs.onattribend(su.NoValue, this.index), this.state = g.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(u) {
    u === T.DoubleQuote ? (this.state = g.InAttributeValueDq, this.sectionStart = this.index + 1) : u === T.SingleQuote ? (this.state = g.InAttributeValueSq, this.sectionStart = this.index + 1) : du(u) || (this.sectionStart = this.index, this.state = g.InAttributeValueNq, this.stateInAttributeValueNoQuotes(u));
  }
  handleInAttributeValue(u, i) {
    u === i || !this.decodeEntities && this.fastForwardTo(i) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(i === T.DoubleQuote ? su.Double : su.Single, this.index), this.state = g.BeforeAttributeName) : this.decodeEntities && u === T.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(u) {
    this.handleInAttributeValue(u, T.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(u) {
    this.handleInAttributeValue(u, T.SingleQuote);
  }
  stateInAttributeValueNoQuotes(u) {
    du(u) || u === T.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(su.Unquoted, this.index), this.state = g.BeforeAttributeName, this.stateBeforeAttributeName(u)) : this.decodeEntities && u === T.Amp && this.startEntity();
  }
  stateBeforeDeclaration(u) {
    u === T.OpeningSquareBracket ? (this.state = g.CDATASequence, this.sequenceIndex = 0) : this.state = u === T.Dash ? g.BeforeComment : g.InDeclaration;
  }
  stateInDeclaration(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(u) {
    u === T.Dash ? (this.state = g.InCommentLike, this.currentSequence = Q.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = g.InDeclaration;
  }
  stateInSpecialComment(u) {
    (u === T.Gt || this.fastForwardTo(T.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = g.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(u) {
    const i = u | 32;
    i === Q.ScriptEnd[3] ? this.startSpecial(Q.ScriptEnd, 4) : i === Q.StyleEnd[3] ? this.startSpecial(Q.StyleEnd, 4) : (this.state = g.InTagName, this.stateInTagName(u));
  }
  startEntity() {
    this.baseState = this.state, this.state = g.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? cu.Strict : this.baseState === g.Text || this.baseState === g.InSpecialTag ? cu.Legacy : cu.Attribute);
  }
  stateInEntity() {
    const u = this.entityDecoder.write(this.buffer, this.index - this.offset);
    u >= 0 ? (this.state = this.baseState, u === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === g.Text || this.state === g.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === g.InAttributeValueDq || this.state === g.InAttributeValueSq || this.state === g.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const u = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case g.Text: {
          this.stateText(u);
          break;
        }
        case g.SpecialStartSequence: {
          this.stateSpecialStartSequence(u);
          break;
        }
        case g.InSpecialTag: {
          this.stateInSpecialTag(u);
          break;
        }
        case g.CDATASequence: {
          this.stateCDATASequence(u);
          break;
        }
        case g.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(u);
          break;
        }
        case g.InAttributeName: {
          this.stateInAttributeName(u);
          break;
        }
        case g.InCommentLike: {
          this.stateInCommentLike(u);
          break;
        }
        case g.InSpecialComment: {
          this.stateInSpecialComment(u);
          break;
        }
        case g.BeforeAttributeName: {
          this.stateBeforeAttributeName(u);
          break;
        }
        case g.InTagName: {
          this.stateInTagName(u);
          break;
        }
        case g.InClosingTagName: {
          this.stateInClosingTagName(u);
          break;
        }
        case g.BeforeTagName: {
          this.stateBeforeTagName(u);
          break;
        }
        case g.AfterAttributeName: {
          this.stateAfterAttributeName(u);
          break;
        }
        case g.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(u);
          break;
        }
        case g.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(u);
          break;
        }
        case g.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(u);
          break;
        }
        case g.AfterClosingTagName: {
          this.stateAfterClosingTagName(u);
          break;
        }
        case g.BeforeSpecialS: {
          this.stateBeforeSpecialS(u);
          break;
        }
        case g.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(u);
          break;
        }
        case g.InSelfClosingTag: {
          this.stateInSelfClosingTag(u);
          break;
        }
        case g.InDeclaration: {
          this.stateInDeclaration(u);
          break;
        }
        case g.BeforeDeclaration: {
          this.stateBeforeDeclaration(u);
          break;
        }
        case g.BeforeComment: {
          this.stateBeforeComment(u);
          break;
        }
        case g.InProcessingInstruction: {
          this.stateInProcessingInstruction(u);
          break;
        }
        case g.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === g.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const u = this.buffer.length + this.offset;
    this.sectionStart >= u || (this.state === g.InCommentLike ? this.currentSequence === Q.CdataEnd ? this.cbs.oncdata(this.sectionStart, u, 0) : this.cbs.oncomment(this.sectionStart, u, 0) : this.state === g.InTagName || this.state === g.BeforeAttributeName || this.state === g.BeforeAttributeValue || this.state === g.AfterAttributeName || this.state === g.InAttributeName || this.state === g.InAttributeValueSq || this.state === g.InAttributeValueDq || this.state === g.InAttributeValueNq || this.state === g.InClosingTagName || this.cbs.ontext(this.sectionStart, u));
  }
  emitCodePoint(u, i) {
    this.baseState !== g.Text && this.baseState !== g.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + i, this.index = this.sectionStart - 1, this.cbs.onattribentity(u)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + i, this.index = this.sectionStart - 1, this.cbs.ontextentity(u, this.sectionStart));
  }
}
const Bu = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), F = /* @__PURE__ */ new Set(["p"]), oe = /* @__PURE__ */ new Set(["thead", "tbody"]), fe = /* @__PURE__ */ new Set(["dd", "dt"]), de = /* @__PURE__ */ new Set(["rt", "rp"]), t0 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", F],
  ["h1", F],
  ["h2", F],
  ["h3", F],
  ["h4", F],
  ["h5", F],
  ["h6", F],
  ["select", Bu],
  ["input", Bu],
  ["output", Bu],
  ["button", Bu],
  ["datalist", Bu],
  ["textarea", Bu],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", fe],
  ["dt", fe],
  ["address", F],
  ["article", F],
  ["aside", F],
  ["blockquote", F],
  ["details", F],
  ["div", F],
  ["dl", F],
  ["fieldset", F],
  ["figcaption", F],
  ["figure", F],
  ["footer", F],
  ["form", F],
  ["header", F],
  ["hr", F],
  ["main", F],
  ["nav", F],
  ["ol", F],
  ["pre", F],
  ["section", F],
  ["table", F],
  ["ul", F],
  ["rt", de],
  ["rp", de],
  ["tbody", oe],
  ["tfoot", oe]
]), r0 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), le = /* @__PURE__ */ new Set(["math", "svg"]), he = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), i0 = /\s|\//;
class a0 {
  constructor(u, i = {}) {
    var n, o, l, f, s;
    this.options = i, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = u ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (n = i.lowerCaseTags) !== null && n !== void 0 ? n : this.htmlMode, this.lowerCaseAttributeNames = (o = i.lowerCaseAttributeNames) !== null && o !== void 0 ? o : this.htmlMode, this.tokenizer = new ((l = i.Tokenizer) !== null && l !== void 0 ? l : e0)(this.options, this), this.foreignContext = [!this.htmlMode], (s = (f = this.cbs).onparserinit) === null || s === void 0 || s.call(f, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(u, i) {
    var n, o;
    const l = this.getSlice(u, i);
    this.endIndex = i - 1, (o = (n = this.cbs).ontext) === null || o === void 0 || o.call(n, l), this.startIndex = i;
  }
  /** @internal */
  ontextentity(u, i) {
    var n, o;
    this.endIndex = i - 1, (o = (n = this.cbs).ontext) === null || o === void 0 || o.call(n, ue(u)), this.startIndex = i;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(u) {
    return this.htmlMode && r0.has(u);
  }
  /** @internal */
  onopentagname(u, i) {
    this.endIndex = i;
    let n = this.getSlice(u, i);
    this.lowerCaseTagNames && (n = n.toLowerCase()), this.emitOpenTag(n);
  }
  emitOpenTag(u) {
    var i, n, o, l;
    this.openTagStart = this.startIndex, this.tagname = u;
    const f = this.htmlMode && t0.get(u);
    if (f)
      for (; this.stack.length > 0 && f.has(this.stack[0]); ) {
        const s = this.stack.shift();
        (n = (i = this.cbs).onclosetag) === null || n === void 0 || n.call(i, s, !0);
      }
    this.isVoidElement(u) || (this.stack.unshift(u), this.htmlMode && (le.has(u) ? this.foreignContext.unshift(!0) : he.has(u) && this.foreignContext.unshift(!1))), (l = (o = this.cbs).onopentagname) === null || l === void 0 || l.call(o, u), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(u) {
    var i, n;
    this.startIndex = this.openTagStart, this.attribs && ((n = (i = this.cbs).onopentag) === null || n === void 0 || n.call(i, this.tagname, this.attribs, u), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
  }
  /** @internal */
  onopentagend(u) {
    this.endIndex = u, this.endOpenTag(!1), this.startIndex = u + 1;
  }
  /** @internal */
  onclosetag(u, i) {
    var n, o, l, f, s, m, w, I;
    this.endIndex = i;
    let y = this.getSlice(u, i);
    if (this.lowerCaseTagNames && (y = y.toLowerCase()), this.htmlMode && (le.has(y) || he.has(y)) && this.foreignContext.shift(), this.isVoidElement(y))
      this.htmlMode && y === "br" && ((f = (l = this.cbs).onopentagname) === null || f === void 0 || f.call(l, "br"), (m = (s = this.cbs).onopentag) === null || m === void 0 || m.call(s, "br", {}, !0), (I = (w = this.cbs).onclosetag) === null || I === void 0 || I.call(w, "br", !1));
    else {
      const q = this.stack.indexOf(y);
      if (q !== -1)
        for (let B = 0; B <= q; B++) {
          const v = this.stack.shift();
          (o = (n = this.cbs).onclosetag) === null || o === void 0 || o.call(n, v, B !== q);
        }
      else
        this.htmlMode && y === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
    }
    this.startIndex = i + 1;
  }
  /** @internal */
  onselfclosingtag(u) {
    this.endIndex = u, this.options.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(!1), this.startIndex = u + 1) : this.onopentagend(u);
  }
  closeCurrentTag(u) {
    var i, n;
    const o = this.tagname;
    this.endOpenTag(u), this.stack[0] === o && ((n = (i = this.cbs).onclosetag) === null || n === void 0 || n.call(i, o, !u), this.stack.shift());
  }
  /** @internal */
  onattribname(u, i) {
    this.startIndex = u;
    const n = this.getSlice(u, i);
    this.attribname = this.lowerCaseAttributeNames ? n.toLowerCase() : n;
  }
  /** @internal */
  onattribdata(u, i) {
    this.attribvalue += this.getSlice(u, i);
  }
  /** @internal */
  onattribentity(u) {
    this.attribvalue += ue(u);
  }
  /** @internal */
  onattribend(u, i) {
    var n, o;
    this.endIndex = i, (o = (n = this.cbs).onattribute) === null || o === void 0 || o.call(n, this.attribname, this.attribvalue, u === su.Double ? '"' : u === su.Single ? "'" : u === su.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(u) {
    const i = u.search(i0);
    let n = i < 0 ? u : u.substr(0, i);
    return this.lowerCaseTagNames && (n = n.toLowerCase()), n;
  }
  /** @internal */
  ondeclaration(u, i) {
    this.endIndex = i;
    const n = this.getSlice(u, i);
    if (this.cbs.onprocessinginstruction) {
      const o = this.getInstructionName(n);
      this.cbs.onprocessinginstruction(`!${o}`, `!${n}`);
    }
    this.startIndex = i + 1;
  }
  /** @internal */
  onprocessinginstruction(u, i) {
    this.endIndex = i;
    const n = this.getSlice(u, i);
    if (this.cbs.onprocessinginstruction) {
      const o = this.getInstructionName(n);
      this.cbs.onprocessinginstruction(`?${o}`, `?${n}`);
    }
    this.startIndex = i + 1;
  }
  /** @internal */
  oncomment(u, i, n) {
    var o, l, f, s;
    this.endIndex = i, (l = (o = this.cbs).oncomment) === null || l === void 0 || l.call(o, this.getSlice(u, i - n)), (s = (f = this.cbs).oncommentend) === null || s === void 0 || s.call(f), this.startIndex = i + 1;
  }
  /** @internal */
  oncdata(u, i, n) {
    var o, l, f, s, m, w, I, y, q, B;
    this.endIndex = i;
    const v = this.getSlice(u, i - n);
    !this.htmlMode || this.options.recognizeCDATA ? ((l = (o = this.cbs).oncdatastart) === null || l === void 0 || l.call(o), (s = (f = this.cbs).ontext) === null || s === void 0 || s.call(f, v), (w = (m = this.cbs).oncdataend) === null || w === void 0 || w.call(m)) : ((y = (I = this.cbs).oncomment) === null || y === void 0 || y.call(I, `[CDATA[${v}]]`), (B = (q = this.cbs).oncommentend) === null || B === void 0 || B.call(q)), this.startIndex = i + 1;
  }
  /** @internal */
  onend() {
    var u, i;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let n = 0; n < this.stack.length; n++)
        this.cbs.onclosetag(this.stack[n], !0);
    }
    (i = (u = this.cbs).onend) === null || i === void 0 || i.call(u);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var u, i, n, o;
    (i = (u = this.cbs).onreset) === null || i === void 0 || i.call(u), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (o = (n = this.cbs).onparserinit) === null || o === void 0 || o.call(n, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(u) {
    this.reset(), this.end(u);
  }
  getSlice(u, i) {
    for (; u - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let n = this.buffers[0].slice(u - this.bufferOffset, i - this.bufferOffset);
    for (; i - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), n += this.buffers[0].slice(0, i - this.bufferOffset);
    return n;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(u) {
    var i, n;
    if (this.ended) {
      (n = (i = this.cbs).onerror) === null || n === void 0 || n.call(i, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(u), this.tokenizer.running && (this.tokenizer.write(u), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(u) {
    var i, n;
    if (this.ended) {
      (n = (i = this.cbs).onerror) === null || n === void 0 || n.call(i, new Error(".end() after done!"));
      return;
    }
    u && this.write(u), this.ended = !0, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(u) {
    this.write(u);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(u) {
    this.end(u);
  }
}
var be = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function n0(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function c0(r) {
  if (r.__esModule)
    return r;
  var u = r.default;
  if (typeof u == "function") {
    var i = function n() {
      return this instanceof n ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    i.prototype = u.prototype;
  } else
    i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(i, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), i;
}
var Te = {}, pe = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, s0 = /\n/g, o0 = /^\s*/, f0 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, d0 = /^:\s*/, l0 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, h0 = /^[;\s]*/, b0 = /^\s+|\s+$/g, p0 = `
`, me = "/", xe = "*", Au = "", m0 = "comment", x0 = "declaration", g0 = function(r, u) {
  if (typeof r != "string")
    throw new TypeError("First argument must be a string");
  if (!r)
    return [];
  u = u || {};
  var i = 1, n = 1;
  function o(v) {
    var S = v.match(s0);
    S && (i += S.length);
    var C = v.lastIndexOf(p0);
    n = ~C ? v.length - C : n + v.length;
  }
  function l() {
    var v = { line: i, column: n };
    return function(S) {
      return S.position = new f(v), w(), S;
    };
  }
  function f(v) {
    this.start = v, this.end = { line: i, column: n }, this.source = u.source;
  }
  f.prototype.content = r;
  function s(v) {
    var S = new Error(
      u.source + ":" + i + ":" + n + ": " + v
    );
    if (S.reason = v, S.filename = u.source, S.line = i, S.column = n, S.source = r, !u.silent)
      throw S;
  }
  function m(v) {
    var S = v.exec(r);
    if (S) {
      var C = S[0];
      return o(C), r = r.slice(C.length), S;
    }
  }
  function w() {
    m(o0);
  }
  function I(v) {
    var S;
    for (v = v || []; S = y(); )
      S !== !1 && v.push(S);
    return v;
  }
  function y() {
    var v = l();
    if (!(me != r.charAt(0) || xe != r.charAt(1))) {
      for (var S = 2; Au != r.charAt(S) && (xe != r.charAt(S) || me != r.charAt(S + 1)); )
        ++S;
      if (S += 2, Au === r.charAt(S - 1))
        return s("End of comment missing");
      var C = r.slice(2, S - 2);
      return n += 2, o(C), r = r.slice(S), n += 2, v({
        type: m0,
        comment: C
      });
    }
  }
  function q() {
    var v = l(), S = m(f0);
    if (S) {
      if (y(), !m(d0))
        return s("property missing ':'");
      var C = m(l0), H = v({
        type: x0,
        property: ge(S[0].replace(pe, Au)),
        value: C ? ge(C[0].replace(pe, Au)) : Au
      });
      return m(h0), H;
    }
  }
  function B() {
    var v = [];
    I(v);
    for (var S; S = q(); )
      S !== !1 && (v.push(S), I(v));
    return v;
  }
  return w(), B();
};
function ge(r) {
  return r ? r.replace(b0, Au) : Au;
}
var w0 = be && be.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Te, "__esModule", { value: !0 });
var y0 = w0(g0);
function E0(r, u) {
  var i = null;
  if (!r || typeof r != "string")
    return i;
  var n = (0, y0.default)(r), o = typeof u == "function";
  return n.forEach(function(l) {
    if (l.type === "declaration") {
      var f = l.property, s = l.value;
      o ? u(f, s, l) : s && (i = i || {}, i[f] = s);
    }
  }), i;
}
var we = Te.default = E0;
const A0 = we.default || we;
class I0 extends Error {
  constructor(u) {
    super(), this.message = u;
  }
  toString() {
    return "ParseError: " + this.message;
  }
}
class Et extends Error {
  constructor(u) {
    super(), this.message = u;
  }
  toString() {
    return "LayoutError: " + this.message;
  }
}
class Be {
  /**
   * åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹
   * @param {string} type
   * @param {string} display
   */
  constructor(u, i) {
    this.type = u, this.display = i;
  }
}
class _e extends Be {
  /**
   * åˆ›å»ºä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹
   * @param text æ–‡æœ¬å†…å®¹
   */
  constructor(u) {
    super(Pu.Text, xu.Inline), this.text = u;
  }
}
class Gu extends Be {
  /**
   * åˆ›å»ºä¸€ä¸ªæ™®é€šèŠ‚ç‚¹
   * @param {string} tag
   * @param {Object} attrs
   * @param {string} display
   * @param {Object} style
   * @param {Array<NodeModel>} children
   */
  constructor(i, {
    attrs: n = {},
    style: o = {},
    display: l = xu.Block,
    children: f = []
  } = {}) {
    super(Pu.Element, l);
    L(this, "style", {});
    L(this, "attrs", {});
    L(this, "children", []);
    L(this, "tag", "");
    this.tag = i, this.attrs = n, this.style = Object.freeze(o), this.children = f;
  }
}
class Pu {
}
L(Pu, "Text", "text"), L(Pu, "Element", "element");
class xu {
}
L(xu, "Block", "block"), L(xu, "Inline", "inline");
class Fu {
  /**
   * æ„å»ºæ¨¡å‹
   * @param {String} type is PrintType
   * @param {String | Array} content
   */
  constructor(u, i) {
    /**
     * æ‰“å°èŠ‚ç‚¹ç±»å‹
     * @type {string}
     */
    L(this, "type");
    /**
     * æ‰“å°èŠ‚ç‚¹å†…å®¹
     * @type {string | Array}
     */
    L(this, "content");
    this.type = u, this.content = i;
  }
}
class Eu extends Fu {
  /**
   * åˆ›å»ºä¸€ä¸ªæ–‡æœ¬æ‰“å°èŠ‚ç‚¹
   * @param {Array<TextChildPrintNodeModel>} content å­æ–‡æœ¬ï¼Œæ–‡æœ¬å†…å®¹æ•°ç»„ã€‚
   * @param {string} align å¯¹é½æ–¹å¼
   * @param {boolean} isBr æ˜¯å¦ä¸ºæ¢è¡Œç¬¦
   */
  constructor(i, {
    align: n = "left",
    isBr: o = !1
  } = {}) {
    super(K.text, i || []);
    /**
     * å¯¹é½æ–¹å¼
     * @type {string}
     */
    L(this, "align", "left");
    /**
     * æ˜¯å¦ä¸ºæ¢è¡Œç¬¦
     * @type {boolean}
     */
    L(this, "isBr", !1);
    this.align = n, this.isBr = o;
  }
}
class pu extends Fu {
  /**
   * åˆ›å»ºä¸€ä¸ªæ–‡æœ¬å­èŠ‚ç‚¹
   * @param {string} content æ–‡æœ¬å†…å®¹
   * @param {string} align å¯¹é½æ–¹å¼
   * @param {string} fontSize å­—ä½“å¤§å°ï¼Œä»…remå•ä½ï¼Œä¸”å€¼ä¸ºæ•´æ•°ã€‚å¦‚ï¼š1remï¼Œ2remï¼Œ3remã€‚è¿™è¡¨ç¤ºå°†å­—æ”¾å¤§çš„å€æ•°
   * @param {boolean} isBold æ˜¯å¦åŠ ç²—
   * @param {number} scaleWidth å®½åº¦ç¼©æ”¾å€æ•°ï¼Œä»…æ”¯æŒæ•´æ•°
   * @param {number} scaleHeight é«˜åº¦ç¼©æ”¾å€æ•°ï¼Œä»…æ”¯æŒæ•´æ•°
   * @param {string} fontStyle å­—ä½“æ ·å¼ï¼Œnormalï¼šæ­£å¸¸ï¼Œitalicï¼šæ–œä½“
   * @param {string} textDecorationLine æ–‡æœ¬ä¿®é¥°ï¼Œnoneï¼šæ— ï¼Œunderlineï¼šä¸‹åˆ’çº¿ï¼Œline-throughï¼šåˆ é™¤çº¿
   */
  constructor(i, {
    fontSize: n = "1rem",
    isBold: o = !1,
    scaleWidth: l = 1,
    scaleHeight: f = 1,
    fontStyle: s = Cu.normal,
    textDecorationLine: m = Nu.none
  } = {}) {
    super(K.textSpan, i);
    L(this, "fontSize", "1rem");
    L(this, "isBold", !1);
    L(this, "scaleWidth", 1);
    L(this, "scaleHeight", 1);
    L(this, "fontStyle", Cu.normal);
    L(this, "textDecorationLine", Nu.none);
    this.fontSize = n, this.isBold = o, this.scaleWidth = l, this.scaleHeight = f, this.fontStyle = s, this.textDecorationLine = m;
  }
  /**
   * æ ¹æ®cssæ ·å¼åˆ›å»ºä¸€ä¸ªæ–‡æœ¬å­èŠ‚ç‚¹
   * @param {Object} css cssæ ·å¼
   * @param {string} content å¯é€‰å‚æ•°ï¼Œæ–‡æœ¬å†…å®¹
   * @returns {TextChildPrintNodeModel}
   */
  static fromCss(i = {}, n = "") {
    let o = i["font-size"] || "1rem", l = i["font-weight"] === "bold" || i["font-weight"] === "600", f = i["scale-width"] || 1, s = i["scale-height"] || 1, m = i["font-style"] || Cu.normal, w = i["text-decoration-line"] || Nu.none;
    return new pu(n, {
      fontSize: o,
      isBold: l,
      scaleWidth: parseInt(f),
      scaleHeight: parseInt(s),
      fontStyle: m,
      textDecorationLine: w
    });
  }
}
class S0 extends Fu {
  /**
   * åˆ›å»ºä¸€ä¸ªå›¾ç‰‡æ‰“å°èŠ‚ç‚¹
   * @param content å›¾ç‰‡å†…å®¹ï¼Œå¯ä»¥æ˜¯base64ï¼Œä¹Ÿå¯ä»¥æ˜¯å›¾ç‰‡åœ°å€
   * @param width å®½åº¦ï¼Œå•ä½mm
   * @param height é«˜åº¦ï¼Œå•ä½mm
   */
  constructor(u, {
    width: i = "30mm",
    height: n = "30mm"
  }) {
    super(K.image, u), this.width = i, this.height = n;
  }
}
class v0 extends Fu {
  /**
   * åˆ›å»ºä¸€ä¸ªäºŒç»´ç æ‰“å°èŠ‚ç‚¹
   * @param content äºŒç»´ç å†…å®¹
   * @param width å®½åº¦ï¼Œå•ä½mm
   * @param height é«˜åº¦ï¼Œå•ä½mm
   */
  constructor(u, {
    width: i = "30mm",
    height: n = "30mm"
  }) {
    super(K.qrcode, u), this.width = i, this.height = n;
  }
}
class T0 extends Fu {
  /**
   * åˆ›å»ºä¸€ä¸ªæ¡å½¢ç æ‰“å°èŠ‚ç‚¹
   * @param content æ¡å½¢ç å†…å®¹
   * @param height é«˜åº¦ï¼Œå•ä½mm
   */
  constructor(u, {
    height: i = "30mm"
  }) {
    super(K.barcode, u), this.height = i;
  }
}
class Su extends Fu {
  // çº¿å‹
  constructor(i, n) {
    super(K.line, "");
    L(this, "width", "1px");
    // çº¿å®½
    L(this, "lineType", "solid");
    this.width = i, this.lineType = n;
  }
  /**
   * æ ¹æ® border style å€¼åˆ›å»ºä¸€ä¸ªçº¿æ‰“å°èŠ‚ç‚¹
   * @param style {Object}
   * @returns {LinePrintNodeModel}
   */
  static fromCss(i = {}) {
    let n = i.border || i["border-top"] || i["border-bottom"] || "";
    if (n)
      return Su.fromBorderStyle(n);
    let o = "1px", l = "solid";
    return i.width && i.width.endsWith("px") && (o = i.width), i["border-style"] && (l = i["border-style"]), new Su(o, l);
  }
  static fromBorderStyle(i) {
    let n = i.split(" "), o = "1px", l = "solid";
    return n.forEach((f, s) => {
      f.endsWith("px") ? o = f : (f === "solid" || f === "dashed" || f === "dotted") && (l = f);
    }), new Su(o, l);
  }
}
class K {
}
L(K, "text", "text"), L(K, "textSpan", "textSpan"), L(K, "image", "image"), L(K, "qrcode", "qrcode"), L(K, "barcode", "barcode"), L(K, "line", "line");
class Cu {
}
L(Cu, "normal", "normal"), L(Cu, "italic", "italic");
class Nu {
  // åˆ é™¤çº¿
}
L(Nu, "none", "none"), // æ— 
L(Nu, "underline", "underline"), // ä¸‹åˆ’çº¿
L(Nu, "lineThrough", "line-through");
function B0(r) {
  return A0(r) || {};
}
function _0(r) {
  const u = [
    "body",
    "p",
    "span",
    "img",
    "qr-code",
    "bar-code",
    "b",
    "strong",
    "br",
    "table",
    "tr",
    "th",
    "td",
    "line"
  ];
  if (u.indexOf(r) === -1)
    throw new I0(`Unsupported tag name: [${r}]. only support ${u.join(", ")}`);
}
function N0(r) {
  const u = ["span", "b", "strong"], i = ["body", "p", "img", "qr-code", "bar-code", "br", "table", "tr", "th", "td", "line"];
  return u.indexOf(r) !== -1 ? xu.Inline : (i.indexOf(r) !== -1, xu.Block);
}
function Zu(r, u) {
  if (r === u || u == null)
    return r;
  if (r == null)
    return u;
  let i = {};
  for (let n in u)
    i[n] = u[n];
  for (let n in r)
    i[n] = r[n];
  return i;
}
function L0(r) {
  return r.charCodeAt ? r.charCodeAt(0) < 256 : /[\x00-\xff]/g.test(r);
}
function ie(r, u) {
  if (r == null || r === "")
    return 0;
  let i = L0(r) ? 1 : 2;
  if (u["font-size"])
    try {
      i *= parseInt(u["font-size"]);
    } catch (n) {
      console.error(`getCharWidth parseInt error, font-size:${u["font-size"]}, `, n);
    }
  if (u["scale-width"])
    try {
      i *= parseInt(u["scale-width"]);
    } catch (n) {
      console.error(`getCharWidth parseInt error, scale-width:${u["scale-width"]}, `, n);
    }
  return i;
}
function q0(r, u) {
  let i = 0;
  for (let n = 0; n < r.length; n++)
    i += ie(r[n], u);
  return i;
}
function F0(r) {
  let u = 0;
  for (let i = 0; i < r.content.length; i++)
    u += ie(r.content[i], {
      "font-size": r.fontSize,
      "scale-width": r.scaleWidth
    });
  return u;
}
function ye(r) {
  let u = 0;
  for (let i of r.content)
    u += F0(i);
  return u;
}
function Wu(r) {
  return new pu(" ".repeat(r));
}
function k0(r) {
  let u = Array.from(r), i = [], n = [];
  for (let s = 0; s < u.length; s++)
    u[s] === "auto" ? n.push(s) : i.push(u[s]);
  let o = i.reduce((s, m) => s + m, 0), l;
  n.length > 0 && (l = 1 / n.length);
  let f = 1 - o;
  for (const s of n)
    u[s] = parseFloat((f * l).toFixed(2));
  return u;
}
class At {
  /**
   * æ’ç‰ˆå‚æ•°
   * @param {number} width æœ‰æ•ˆæ‰“å°å®½åº¦ï¼Œå•ä½mm
   * @param {number} rowCharCount æ¯è¡Œå­—æ¯æ•°ï¼Œæ±‰å­—ç®—ä¸¤ä¸ªå­—ç¬¦
   * @param {number} dpi æ‰“å°æœºdpi
   */
  constructor({ width: u = 48, rowCharCount: i = 32, dpi: n = 203 } = {}) {
    this.width = u, this.rowCharCount = i, this.dpi = n;
  }
}
const R0 = ["b", "strong"];
class D0 {
  /**
   *
   @param {TypographyOptions} options æ’ç‰ˆå‚æ•°@param {ElementNodeModel} ast è§£æåçš„ AST æ ‘
   */
  constructor(u) {
    this.options = u;
  }
  /**
   * æ‰§è¡Œæ’ç‰ˆ
   * @param {ElementNodeModel} ast è§£æåçš„ AST æ ‘
   * @return {Array<PrintNodeModel>} æ’ç‰ˆåçš„ AST æ ‘
   */
  layout(u) {
    const i = new Yu(this.options.rowCharCount);
    return this.layoutNode(u, i, null), i.result.filter((n) => n instanceof Eu ? n.content.length > 0 || n.isBr : !0);
  }
  /**
   * æ’ç‰ˆèŠ‚ç‚¹
   * @param {NodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @param {LayoutContext} context ä¸Šä¸‹æ–‡
   * @param {ElementNodeModel} parent çˆ¶èŠ‚ç‚¹
   */
  layoutNode(u, i, n) {
    if (u instanceof Gu) {
      let o = !1;
      if (n && n instanceof Gu && (u.style = Zu(u.style, n.style)), R0.includes(u.tag) && (u.style["font-weight"] = "600"), u.tag === "img")
        this.createImagePrint(u, i);
      else if (u.tag === "qr-code")
        this.createQrcodePrint(u, i);
      else if (u.tag === "bar-code")
        this.createBarcodePrint(u, i);
      else if (u.tag === "br")
        this.createTextPrint(u, i, !0);
      else if (u.tag === "line")
        this.createLinePrint(u, i);
      else if (u.tag === "table")
        this.layoutTable(u, i, n);
      else if (u.display === xu.Block && (this.createTextPrint(u, i), o = !0), u.children) {
        for (let l of u.children)
          this.layoutNode(l, i, u);
        o && (i.current = null);
      }
    } else
      u instanceof _e && this.layoutText(u, i, n);
  }
  /**
   * æ’ç‰ˆæ–‡æœ¬èŠ‚ç‚¹
   * @param {TextNodeModel} textNode æ–‡æœ¬èŠ‚ç‚¹
   * @param {Object} context ä¸Šä¸‹æ–‡
   * @param {ElementNodeModel} parent çˆ¶èŠ‚ç‚¹
   */
  layoutText(u, i, n) {
    i.current == null && this.createTextPrint(n, i);
    let o = n.style, l = u.text, f = pu.fromCss(o);
    for (; l.length > 0; ) {
      let s = l[0];
      const m = ie(s, o);
      if (i.charBalance < m) {
        f.content.length > 0 && (i.current.content.push(f), f = pu.fromCss(o));
        let w = new Eu("", {
          align: i.current.align
        });
        i.pushNode(w), i.current = w;
      }
      if (i.charBalance >= m)
        f.content = f.content + s, i.charBalance = i.charBalance - m, l = l.slice(1);
      else
        break;
    }
    f.content.length > 0 && i.current.content.push(f);
  }
  /**
   * æ’ç‰ˆè¡¨æ ¼èŠ‚ç‚¹ï¼Œè¡¨æ ¼çš„åˆ—æ•°æ ¹æ®ç¬¬ä¸€è¡Œçš„ td/th çš„æ•°é‡æ¥ç¡®å®šã€‚å®½åº¦ä¹Ÿä¸€æ ·æ ¹æ®ç¬¬ä¸€è¡Œå†³å®šã€‚
   * @param {ElementNodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @param {LayoutContext} context ä¸Šä¸‹æ–‡
   * @param {ElementNodeModel} parent çˆ¶èŠ‚ç‚¹
   */
  layoutTable(u, i, n) {
    const o = this.allocateFirstRowSpace(u), l = [], f = u.style["text-align"] || "left", s = (m, w) => {
      let I = [], y = 0, q = m.children.filter((B) => B.tag === "td" || B.tag === "th");
      m.style["border-top"] && l.push(Su.fromBorderStyle(m.style["border-top"]));
      for (let B = 0; B < q.length; B++) {
        let v = q[B];
        if (B >= o.length)
          break;
        v.style = Zu(v.style, m.style);
        let S = this.options.rowCharCount * o[B];
        S = Math.floor(S);
        let C = new Yu(S);
        this.layoutNode(v, C, w), C.result.forEach((H) => {
          if (!(H instanceof Eu))
            return;
          H.align = f;
          let M = ye(H);
          if (!(M >= S)) {
            if (M < S && f === "left") {
              let J = Wu(S - M);
              H.content.push(J);
            } else if (M < S && f === "right") {
              let J = Wu(S - M);
              H.content.unshift(J);
            } else if (M < S && f === "center") {
              let J = S - M, gu = Math.floor(J / 2), uu = Wu(gu);
              H.content.unshift(uu);
              let wu = Wu(J - gu);
              H.content.push(wu);
            }
          }
        }), I.push(C.result), y = Math.max(y, C.result.length);
      }
      for (let B = 0; B < y; B++) {
        let v = new Eu([], { align: "left" });
        for (let S = 0; S < I.length; S++) {
          let H = I[S][B];
          if (H)
            H.content.forEach((M) => {
              v.content.push(M);
            });
          else {
            let M = this.options.rowCharCount * o[S];
            M = Math.floor(M);
            let J = new pu(" ".repeat(M));
            v.content.push(J);
          }
        }
        l.push(v);
      }
      m.style["border-bottom"] && l.push(Su.fromBorderStyle(m.style["border-bottom"]));
    };
    for (let m of u.children)
      m.style = Zu(m.style, u.style), m.tag === "tr" && s(m, u);
    i.result.push(...l);
  }
  /**
   * åˆ†é…è¡Œç©ºé—´
   * @param {ElementNodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @returns {Array<number>} è¡Œç©ºé—´
   */
  allocateFirstRowSpace(u) {
    let i = [];
    for (let n of u.children)
      if (n.tag === "tr") {
        for (let o of n.children)
          if (o.tag === "td" || o.tag === "th") {
            let l = o.attrs.width || o.style.width;
            l && l.endsWith("%") ? i.push(parseFloat(l) / 100) : i.push("auto");
          }
        break;
      }
    return k0(i);
  }
  /**
   * åˆ›å»ºæ–‡æœ¬æ‰“å°èŠ‚ç‚¹
   * @param {ElementNodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @param {LayoutContext} context ä¸Šä¸‹æ–‡
   * @param {boolean} isBr æ˜¯å¦æ˜¯ br èŠ‚ç‚¹
   */
  createTextPrint(u, i, n = !1) {
    let o = i.current;
    o && o instanceof Eu && o.content.length === 0 && !n && i.result.pop();
    let l = new Eu("", {
      align: u.style["text-align"],
      isBr: n
    });
    i.pushNode(l), i.current = l;
  }
  /**
   * åˆ›å»ºæ¡ç æ‰“å°èŠ‚ç‚¹, é»˜è®¤é«˜åº¦20mm
   * @param {ElementNodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @param {LayoutContext} context ä¸Šä¸‹æ–‡
   */
  createBarcodePrint(u, i) {
    let n = u.attrs.value;
    if (n == null)
      return;
    let o = u.attrs.height || u.style.height;
    i.pushNode(new T0(
      n,
      { height: (this.getMM(o) || 20) + "mm" }
    ));
  }
  /**
   * åˆ›å»ºäºŒç»´ç æ‰“å°èŠ‚ç‚¹
   * @param {ElementNodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @param {LayoutContext} context ä¸Šä¸‹æ–‡
   */
  createQrcodePrint(u, i) {
    let n = u.attrs.value;
    if (n == null)
      return null;
    let o = u.attrs.width || u.style.width, l = u.attrs.height || u.style.height, { width: f, height: s } = this.getSafeWH(o, l);
    this.getMM(s) === 0 && (s = f), i.pushNode(new v0(n, { width: f, height: s }));
  }
  /**
   * åˆ›å»ºå›¾ç‰‡æ‰“å°èŠ‚ç‚¹
   * @param {ElementNodeModel} nodeModel èŠ‚ç‚¹æ¨¡å‹
   * @param {LayoutContext} context ä¸Šä¸‹æ–‡
   */
  createImagePrint(u, i) {
    let n = u.attrs.src;
    if (n == null)
      return null;
    let o = u.attrs.width || u.style.width, l = u.attrs.height || u.style.height;
    i.pushNode(new S0(n, this.getSafeWH(o, l)));
  }
  /**
   * åˆ›å»ºåˆ†å‰²çº¿æ‰“å°èŠ‚ç‚¹ï¼Œå¦‚æœæ²¡ä¼ è‡ªå®šä¹‰å†…å®¹ï¼Œåˆ™ä½¿ç”¨ border æ ·å¼ã€‚å¦åˆ™æ‰“å°è‡ªå®šä¹‰å†…å®¹
   * @param nodeModel {ElementNodeModel} line èŠ‚ç‚¹
   * @param context {LayoutContext} ä¸Šä¸‹æ–‡
   */
  createLinePrint(u, i) {
    if (u.children.length === 0 && u.attrs.char == null) {
      i.pushNode(Su.fromCss(u.style));
      return;
    }
    let n = new Yu(this.options.rowCharCount);
    for (let f of u.children)
      this.layoutNode(f, n, u);
    n.result = n.result.filter((f) => f.type === Pu.Text);
    let o = n.result[0];
    o == null && (o = new Eu([], { align: "center" }));
    let l = ye(o);
    if (l < this.options.rowCharCount) {
      let f = u.attrs.char || "-", s = q0(f, u.style), m = this.options.rowCharCount - l, w = Math.floor(m / s), I = Math.floor(w / 2), y = w - I;
      o.content.unshift(pu.fromCss(u.style, f.repeat(I))), o.content.push(pu.fromCss(u.style, f.repeat(y)));
    }
    i.pushNode(o);
  }
  /**
   * è·å–å®‰å…¨çš„å®½é«˜ï¼Œå¦‚æœå®½åº¦è¶…å‡ºäº†æ‰“å°æœºçš„å®½åº¦ï¼Œå°±ç¼©å°å®½åº¦ï¼Œé«˜åº¦ä¹ŸæŒ‰æ¯”ä¾‹ç¼©å°
   * @param width {string|number} æ ·å¼å€¼ï¼Œä¾‹å¦‚ 100px 100pt 100mm 100% 100rem
   * @param height {string|number} æ ·å¼å€¼ï¼Œä¾‹å¦‚ 100px 100pt 100mm 100% 100rem
   * @return {{width, height}} è¿”å›å®‰å…¨çš„å®½é«˜
   */
  getSafeWH(u, i) {
    return u = this.getMM(u, this.options.width), i = this.getMM(i), u > this.options.width && (i = i * this.options.width / u, u = this.options.width), { width: u + "mm", height: i + "mm" };
  }
  /**
   * è·å–æ ·å¼å®½åº¦ï¼Œå•ä½æ˜¯ mmï¼Œå¦‚æœä¸æ˜¯ mm å•ä½ï¼Œä¹ŸæŒ‰ç…§ mm è®¡ç®—
   * @param {string|number} value æ ·å¼å€¼, ä¾‹å¦‚ 100px 100pt 100mm 100% 100rem
   * @param {number} defaultValue é»˜è®¤å€¼
   * @returns {number} è¿”å›æ•°å€¼
   */
  getMM(u, i = 0) {
    if (u == null)
      return i;
    try {
      return parseInt(u);
    } catch {
      return i;
    }
  }
}
class Yu {
  constructor(u) {
    /**
     * ä¸€ä¸ª item è¡¨ç¤ºä¸€è¡Œæ‰“å°å†…å®¹
     * @type {Array<PrintNodeModel>}
     */
    L(this, "result", []);
    L(this, "current", null);
    L(this, "charBalance", 0);
    L(this, "initCharBalance", 0);
    this.charBalance = u, this.initCharBalance = u;
  }
  pushNode(u) {
    this.result.push(u), this.charBalance = this.initCharBalance, this.current = null;
  }
}
var Ne = {}, U0 = null;
const C0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: U0
}, Symbol.toStringTag, { value: "Module" })), P0 = /* @__PURE__ */ c0(C0);
var Le = {}, qe = {}, $u = {};
$u.byteLength = V0;
$u.toByteArray = W0;
$u.fromByteArray = $0;
var ou = [], Y = [], O0 = typeof Uint8Array < "u" ? Uint8Array : Array, Ku = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var _u = 0, M0 = Ku.length; _u < M0; ++_u)
  ou[_u] = Ku[_u], Y[Ku.charCodeAt(_u)] = _u;
Y["-".charCodeAt(0)] = 62;
Y["_".charCodeAt(0)] = 63;
function Fe(r) {
  var u = r.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var i = r.indexOf("=");
  i === -1 && (i = u);
  var n = i === u ? 0 : 4 - i % 4;
  return [i, n];
}
function V0(r) {
  var u = Fe(r), i = u[0], n = u[1];
  return (i + n) * 3 / 4 - n;
}
function j0(r, u, i) {
  return (u + i) * 3 / 4 - i;
}
function W0(r) {
  var u, i = Fe(r), n = i[0], o = i[1], l = new O0(j0(r, n, o)), f = 0, s = o > 0 ? n - 4 : n, m;
  for (m = 0; m < s; m += 4)
    u = Y[r.charCodeAt(m)] << 18 | Y[r.charCodeAt(m + 1)] << 12 | Y[r.charCodeAt(m + 2)] << 6 | Y[r.charCodeAt(m + 3)], l[f++] = u >> 16 & 255, l[f++] = u >> 8 & 255, l[f++] = u & 255;
  return o === 2 && (u = Y[r.charCodeAt(m)] << 2 | Y[r.charCodeAt(m + 1)] >> 4, l[f++] = u & 255), o === 1 && (u = Y[r.charCodeAt(m)] << 10 | Y[r.charCodeAt(m + 1)] << 4 | Y[r.charCodeAt(m + 2)] >> 2, l[f++] = u >> 8 & 255, l[f++] = u & 255), l;
}
function H0(r) {
  return ou[r >> 18 & 63] + ou[r >> 12 & 63] + ou[r >> 6 & 63] + ou[r & 63];
}
function G0(r, u, i) {
  for (var n, o = [], l = u; l < i; l += 3)
    n = (r[l] << 16 & 16711680) + (r[l + 1] << 8 & 65280) + (r[l + 2] & 255), o.push(H0(n));
  return o.join("");
}
function $0(r) {
  for (var u, i = r.length, n = i % 3, o = [], l = 16383, f = 0, s = i - n; f < s; f += l)
    o.push(G0(r, f, f + l > s ? s : f + l));
  return n === 1 ? (u = r[i - 1], o.push(
    ou[u >> 2] + ou[u << 4 & 63] + "=="
  )) : n === 2 && (u = (r[i - 2] << 8) + r[i - 1], o.push(
    ou[u >> 10] + ou[u >> 4 & 63] + ou[u << 2 & 63] + "="
  )), o.join("");
}
var ae = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ae.read = function(r, u, i, n, o) {
  var l, f, s = o * 8 - n - 1, m = (1 << s) - 1, w = m >> 1, I = -7, y = i ? o - 1 : 0, q = i ? -1 : 1, B = r[u + y];
  for (y += q, l = B & (1 << -I) - 1, B >>= -I, I += s; I > 0; l = l * 256 + r[u + y], y += q, I -= 8)
    ;
  for (f = l & (1 << -I) - 1, l >>= -I, I += n; I > 0; f = f * 256 + r[u + y], y += q, I -= 8)
    ;
  if (l === 0)
    l = 1 - w;
  else {
    if (l === m)
      return f ? NaN : (B ? -1 : 1) * (1 / 0);
    f = f + Math.pow(2, n), l = l - w;
  }
  return (B ? -1 : 1) * f * Math.pow(2, l - n);
};
ae.write = function(r, u, i, n, o, l) {
  var f, s, m, w = l * 8 - o - 1, I = (1 << w) - 1, y = I >> 1, q = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, B = n ? 0 : l - 1, v = n ? 1 : -1, S = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
  for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (s = isNaN(u) ? 1 : 0, f = I) : (f = Math.floor(Math.log(u) / Math.LN2), u * (m = Math.pow(2, -f)) < 1 && (f--, m *= 2), f + y >= 1 ? u += q / m : u += q * Math.pow(2, 1 - y), u * m >= 2 && (f++, m /= 2), f + y >= I ? (s = 0, f = I) : f + y >= 1 ? (s = (u * m - 1) * Math.pow(2, o), f = f + y) : (s = u * Math.pow(2, y - 1) * Math.pow(2, o), f = 0)); o >= 8; r[i + B] = s & 255, B += v, s /= 256, o -= 8)
    ;
  for (f = f << o | s, w += o; w > 0; r[i + B] = f & 255, B += v, f /= 256, w -= 8)
    ;
  r[i + B - v] |= S * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(r) {
  const u = $u, i = ae, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = s, r.SlowBuffer = M, r.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  r.kMaxLength = o, s.TYPED_ARRAY_SUPPORT = l(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const a = new Uint8Array(1), e = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(a, e), a.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(a) {
    if (a > o)
      throw new RangeError('The value "' + a + '" is invalid for option "size"');
    const e = new Uint8Array(a);
    return Object.setPrototypeOf(e, s.prototype), e;
  }
  function s(a, e, t) {
    if (typeof a == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(a);
    }
    return m(a, e, t);
  }
  s.poolSize = 8192;
  function m(a, e, t) {
    if (typeof a == "string")
      return q(a, e);
    if (ArrayBuffer.isView(a))
      return v(a);
    if (a == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a
      );
    if (ru(a, ArrayBuffer) || a && ru(a.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ru(a, SharedArrayBuffer) || a && ru(a.buffer, SharedArrayBuffer)))
      return S(a, e, t);
    if (typeof a == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const c = a.valueOf && a.valueOf();
    if (c != null && c !== a)
      return s.from(c, e, t);
    const d = C(a);
    if (d)
      return d;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof a[Symbol.toPrimitive] == "function")
      return s.from(a[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a
    );
  }
  s.from = function(a, e, t) {
    return m(a, e, t);
  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
  function w(a) {
    if (typeof a != "number")
      throw new TypeError('"size" argument must be of type number');
    if (a < 0)
      throw new RangeError('The value "' + a + '" is invalid for option "size"');
  }
  function I(a, e, t) {
    return w(a), a <= 0 ? f(a) : e !== void 0 ? typeof t == "string" ? f(a).fill(e, t) : f(a).fill(e) : f(a);
  }
  s.alloc = function(a, e, t) {
    return I(a, e, t);
  };
  function y(a) {
    return w(a), f(a < 0 ? 0 : H(a) | 0);
  }
  s.allocUnsafe = function(a) {
    return y(a);
  }, s.allocUnsafeSlow = function(a) {
    return y(a);
  };
  function q(a, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !s.isEncoding(e))
      throw new TypeError("Unknown encoding: " + e);
    const t = J(a, e) | 0;
    let c = f(t);
    const d = c.write(a, e);
    return d !== t && (c = c.slice(0, d)), c;
  }
  function B(a) {
    const e = a.length < 0 ? 0 : H(a.length) | 0, t = f(e);
    for (let c = 0; c < e; c += 1)
      t[c] = a[c] & 255;
    return t;
  }
  function v(a) {
    if (ru(a, Uint8Array)) {
      const e = new Uint8Array(a);
      return S(e.buffer, e.byteOffset, e.byteLength);
    }
    return B(a);
  }
  function S(a, e, t) {
    if (e < 0 || a.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (a.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let c;
    return e === void 0 && t === void 0 ? c = new Uint8Array(a) : t === void 0 ? c = new Uint8Array(a, e) : c = new Uint8Array(a, e, t), Object.setPrototypeOf(c, s.prototype), c;
  }
  function C(a) {
    if (s.isBuffer(a)) {
      const e = H(a.length) | 0, t = f(e);
      return t.length === 0 || a.copy(t, 0, 0, e), t;
    }
    if (a.length !== void 0)
      return typeof a.length != "number" || Qu(a.length) ? f(0) : B(a);
    if (a.type === "Buffer" && Array.isArray(a.data))
      return B(a.data);
  }
  function H(a) {
    if (a >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return a | 0;
  }
  function M(a) {
    return +a != a && (a = 0), s.alloc(+a);
  }
  s.isBuffer = function(e) {
    return e != null && e._isBuffer === !0 && e !== s.prototype;
  }, s.compare = function(e, t) {
    if (ru(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), ru(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === t)
      return 0;
    let c = e.length, d = t.length;
    for (let h = 0, p = Math.min(c, d); h < p; ++h)
      if (e[h] !== t[h]) {
        c = e[h], d = t[h];
        break;
      }
    return c < d ? -1 : d < c ? 1 : 0;
  }, s.isEncoding = function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0)
      return s.alloc(0);
    let c;
    if (t === void 0)
      for (t = 0, c = 0; c < e.length; ++c)
        t += e[c].length;
    const d = s.allocUnsafe(t);
    let h = 0;
    for (c = 0; c < e.length; ++c) {
      let p = e[c];
      if (ru(p, Uint8Array))
        h + p.length > d.length ? (s.isBuffer(p) || (p = s.from(p)), p.copy(d, h)) : Uint8Array.prototype.set.call(
          d,
          p,
          h
        );
      else if (s.isBuffer(p))
        p.copy(d, h);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      h += p.length;
    }
    return d;
  };
  function J(a, e) {
    if (s.isBuffer(a))
      return a.length;
    if (ArrayBuffer.isView(a) || ru(a, ArrayBuffer))
      return a.byteLength;
    if (typeof a != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof a
      );
    const t = a.length, c = arguments.length > 2 && arguments[2] === !0;
    if (!c && t === 0)
      return 0;
    let d = !1;
    for (; ; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Xu(a).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return se(a).length;
        default:
          if (d)
            return c ? -1 : Xu(a).length;
          e = ("" + e).toLowerCase(), d = !0;
      }
  }
  s.byteLength = J;
  function gu(a, e, t) {
    let c = !1;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
      return "";
    for (a || (a = "utf8"); ; )
      switch (a) {
        case "hex":
          return yu(this, e, t);
        case "utf8":
        case "utf-8":
          return k(this, e, t);
        case "ascii":
          return Z(this, e, t);
        case "latin1":
        case "binary":
          return fu(this, e, t);
        case "base64":
          return _(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return vu(this, e, t);
        default:
          if (c)
            throw new TypeError("Unknown encoding: " + a);
          a = (a + "").toLowerCase(), c = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function uu(a, e, t) {
    const c = a[e];
    a[e] = a[t], a[t] = c;
  }
  s.prototype.swap16 = function() {
    const e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2)
      uu(this, t, t + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4)
      uu(this, t, t + 3), uu(this, t + 1, t + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < e; t += 8)
      uu(this, t, t + 7), uu(this, t + 1, t + 6), uu(this, t + 2, t + 5), uu(this, t + 3, t + 4);
    return this;
  }, s.prototype.toString = function() {
    const e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? k(this, 0, e) : gu.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e) {
    if (!s.isBuffer(e))
      throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : s.compare(this, e) === 0;
  }, s.prototype.inspect = function() {
    let e = "";
    const t = r.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(e, t, c, d, h) {
    if (ru(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e
      );
    if (t === void 0 && (t = 0), c === void 0 && (c = e ? e.length : 0), d === void 0 && (d = 0), h === void 0 && (h = this.length), t < 0 || c > e.length || d < 0 || h > this.length)
      throw new RangeError("out of range index");
    if (d >= h && t >= c)
      return 0;
    if (d >= h)
      return -1;
    if (t >= c)
      return 1;
    if (t >>>= 0, c >>>= 0, d >>>= 0, h >>>= 0, this === e)
      return 0;
    let p = h - d, N = c - t;
    const P = Math.min(p, N), U = this.slice(d, h), O = e.slice(t, c);
    for (let R = 0; R < P; ++R)
      if (U[R] !== O[R]) {
        p = U[R], N = O[R];
        break;
      }
    return p < N ? -1 : N < p ? 1 : 0;
  };
  function wu(a, e, t, c, d) {
    if (a.length === 0)
      return -1;
    if (typeof t == "string" ? (c = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, Qu(t) && (t = d ? 0 : a.length - 1), t < 0 && (t = a.length + t), t >= a.length) {
      if (d)
        return -1;
      t = a.length - 1;
    } else if (t < 0)
      if (d)
        t = 0;
      else
        return -1;
    if (typeof e == "string" && (e = s.from(e, c)), s.isBuffer(e))
      return e.length === 0 ? -1 : ku(a, e, t, c, d);
    if (typeof e == "number")
      return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? d ? Uint8Array.prototype.indexOf.call(a, e, t) : Uint8Array.prototype.lastIndexOf.call(a, e, t) : ku(a, [e], t, c, d);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ku(a, e, t, c, d) {
    let h = 1, p = a.length, N = e.length;
    if (c !== void 0 && (c = String(c).toLowerCase(), c === "ucs2" || c === "ucs-2" || c === "utf16le" || c === "utf-16le")) {
      if (a.length < 2 || e.length < 2)
        return -1;
      h = 2, p /= 2, N /= 2, t /= 2;
    }
    function P(O, R) {
      return h === 1 ? O[R] : O.readUInt16BE(R * h);
    }
    let U;
    if (d) {
      let O = -1;
      for (U = t; U < p; U++)
        if (P(a, U) === P(e, O === -1 ? 0 : U - O)) {
          if (O === -1 && (O = U), U - O + 1 === N)
            return O * h;
        } else
          O !== -1 && (U -= U - O), O = -1;
    } else
      for (t + N > p && (t = p - N), U = t; U >= 0; U--) {
        let O = !0;
        for (let R = 0; R < N; R++)
          if (P(a, U + R) !== P(e, R)) {
            O = !1;
            break;
          }
        if (O)
          return U;
      }
    return -1;
  }
  s.prototype.includes = function(e, t, c) {
    return this.indexOf(e, t, c) !== -1;
  }, s.prototype.indexOf = function(e, t, c) {
    return wu(this, e, t, c, !0);
  }, s.prototype.lastIndexOf = function(e, t, c) {
    return wu(this, e, t, c, !1);
  };
  function V(a, e, t, c) {
    t = Number(t) || 0;
    const d = a.length - t;
    c ? (c = Number(c), c > d && (c = d)) : c = d;
    const h = e.length;
    c > h / 2 && (c = h / 2);
    let p;
    for (p = 0; p < c; ++p) {
      const N = parseInt(e.substr(p * 2, 2), 16);
      if (Qu(N))
        return p;
      a[t + p] = N;
    }
    return p;
  }
  function x(a, e, t, c) {
    return Vu(Xu(e, a.length - t), a, t, c);
  }
  function E(a, e, t, c) {
    return Vu(Ve(e), a, t, c);
  }
  function b(a, e, t, c) {
    return Vu(se(e), a, t, c);
  }
  function A(a, e, t, c) {
    return Vu(je(e, a.length - t), a, t, c);
  }
  s.prototype.write = function(e, t, c, d) {
    if (t === void 0)
      d = "utf8", c = this.length, t = 0;
    else if (c === void 0 && typeof t == "string")
      d = t, c = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(c) ? (c = c >>> 0, d === void 0 && (d = "utf8")) : (d = c, c = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const h = this.length - t;
    if ((c === void 0 || c > h) && (c = h), e.length > 0 && (c < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    d || (d = "utf8");
    let p = !1;
    for (; ; )
      switch (d) {
        case "hex":
          return V(this, e, t, c);
        case "utf8":
        case "utf-8":
          return x(this, e, t, c);
        case "ascii":
        case "latin1":
        case "binary":
          return E(this, e, t, c);
        case "base64":
          return b(this, e, t, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A(this, e, t, c);
        default:
          if (p)
            throw new TypeError("Unknown encoding: " + d);
          d = ("" + d).toLowerCase(), p = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function _(a, e, t) {
    return e === 0 && t === a.length ? u.fromByteArray(a) : u.fromByteArray(a.slice(e, t));
  }
  function k(a, e, t) {
    t = Math.min(a.length, t);
    const c = [];
    let d = e;
    for (; d < t; ) {
      const h = a[d];
      let p = null, N = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
      if (d + N <= t) {
        let P, U, O, R;
        switch (N) {
          case 1:
            h < 128 && (p = h);
            break;
          case 2:
            P = a[d + 1], (P & 192) === 128 && (R = (h & 31) << 6 | P & 63, R > 127 && (p = R));
            break;
          case 3:
            P = a[d + 1], U = a[d + 2], (P & 192) === 128 && (U & 192) === 128 && (R = (h & 15) << 12 | (P & 63) << 6 | U & 63, R > 2047 && (R < 55296 || R > 57343) && (p = R));
            break;
          case 4:
            P = a[d + 1], U = a[d + 2], O = a[d + 3], (P & 192) === 128 && (U & 192) === 128 && (O & 192) === 128 && (R = (h & 15) << 18 | (P & 63) << 12 | (U & 63) << 6 | O & 63, R > 65535 && R < 1114112 && (p = R));
        }
      }
      p === null ? (p = 65533, N = 1) : p > 65535 && (p -= 65536, c.push(p >>> 10 & 1023 | 55296), p = 56320 | p & 1023), c.push(p), d += N;
    }
    return eu(c);
  }
  const W = 4096;
  function eu(a) {
    const e = a.length;
    if (e <= W)
      return String.fromCharCode.apply(String, a);
    let t = "", c = 0;
    for (; c < e; )
      t += String.fromCharCode.apply(
        String,
        a.slice(c, c += W)
      );
    return t;
  }
  function Z(a, e, t) {
    let c = "";
    t = Math.min(a.length, t);
    for (let d = e; d < t; ++d)
      c += String.fromCharCode(a[d] & 127);
    return c;
  }
  function fu(a, e, t) {
    let c = "";
    t = Math.min(a.length, t);
    for (let d = e; d < t; ++d)
      c += String.fromCharCode(a[d]);
    return c;
  }
  function yu(a, e, t) {
    const c = a.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > c) && (t = c);
    let d = "";
    for (let h = e; h < t; ++h)
      d += We[a[h]];
    return d;
  }
  function vu(a, e, t) {
    const c = a.slice(e, t);
    let d = "";
    for (let h = 0; h < c.length - 1; h += 2)
      d += String.fromCharCode(c[h] + c[h + 1] * 256);
    return d;
  }
  s.prototype.slice = function(e, t) {
    const c = this.length;
    e = ~~e, t = t === void 0 ? c : ~~t, e < 0 ? (e += c, e < 0 && (e = 0)) : e > c && (e = c), t < 0 ? (t += c, t < 0 && (t = 0)) : t > c && (t = c), t < e && (t = e);
    const d = this.subarray(e, t);
    return Object.setPrototypeOf(d, s.prototype), d;
  };
  function D(a, e, t) {
    if (a % 1 !== 0 || a < 0)
      throw new RangeError("offset is not uint");
    if (a + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = this[e], h = 1, p = 0;
    for (; ++p < t && (h *= 256); )
      d += this[e + p] * h;
    return d;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = this[e + --t], h = 1;
    for (; t > 0 && (h *= 256); )
      d += this[e + --t] * h;
    return d;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(e, t) {
    return e = e >>> 0, t || D(e, 1, this.length), this[e];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(e, t) {
    return e = e >>> 0, t || D(e, 2, this.length), this[e] | this[e + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(e, t) {
    return e = e >>> 0, t || D(e, 2, this.length), this[e] << 8 | this[e + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  }, s.prototype.readBigUInt64LE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, h = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + c * 2 ** 24;
    return BigInt(d) + (BigInt(h) << BigInt(32));
  }), s.prototype.readBigUInt64BE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], h = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + c;
    return (BigInt(d) << BigInt(32)) + BigInt(h);
  }), s.prototype.readIntLE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = this[e], h = 1, p = 0;
    for (; ++p < t && (h *= 256); )
      d += this[e + p] * h;
    return h *= 128, d >= h && (d -= Math.pow(2, 8 * t)), d;
  }, s.prototype.readIntBE = function(e, t, c) {
    e = e >>> 0, t = t >>> 0, c || D(e, t, this.length);
    let d = t, h = 1, p = this[e + --d];
    for (; d > 0 && (h *= 256); )
      p += this[e + --d] * h;
    return h *= 128, p >= h && (p -= Math.pow(2, 8 * t)), p;
  }, s.prototype.readInt8 = function(e, t) {
    return e = e >>> 0, t || D(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  }, s.prototype.readInt16LE = function(e, t) {
    e = e >>> 0, t || D(e, 2, this.length);
    const c = this[e] | this[e + 1] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, s.prototype.readInt16BE = function(e, t) {
    e = e >>> 0, t || D(e, 2, this.length);
    const c = this[e + 1] | this[e] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, s.prototype.readInt32LE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  }, s.prototype.readInt32BE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  }, s.prototype.readBigInt64LE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (c << 24);
    return (BigInt(d) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  }), s.prototype.readBigInt64BE = bu(function(e) {
    e = e >>> 0, Tu(e, "offset");
    const t = this[e], c = this[e + 7];
    (t === void 0 || c === void 0) && Uu(e, this.length - 8);
    const d = (t << 24) + // Overflow
    this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(d) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + c);
  }), s.prototype.readFloatLE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), i.read(this, e, !0, 23, 4);
  }, s.prototype.readFloatBE = function(e, t) {
    return e = e >>> 0, t || D(e, 4, this.length), i.read(this, e, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(e, t) {
    return e = e >>> 0, t || D(e, 8, this.length), i.read(this, e, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(e, t) {
    return e = e >>> 0, t || D(e, 8, this.length), i.read(this, e, !1, 52, 8);
  };
  function z(a, e, t, c, d, h) {
    if (!s.isBuffer(a))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > d || e < h)
      throw new RangeError('"value" argument is out of bounds');
    if (t + c > a.length)
      throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, c = c >>> 0, !d) {
      const N = Math.pow(2, 8 * c) - 1;
      z(this, e, t, c, N, 0);
    }
    let h = 1, p = 0;
    for (this[t] = e & 255; ++p < c && (h *= 256); )
      this[t + p] = e / h & 255;
    return t + c;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, c = c >>> 0, !d) {
      const N = Math.pow(2, 8 * c) - 1;
      z(this, e, t, c, N, 0);
    }
    let h = c - 1, p = 1;
    for (this[t + h] = e & 255; --h >= 0 && (p *= 256); )
      this[t + h] = e / p & 255;
    return t + c;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  };
  function X(a, e, t, c, d) {
    ce(e, c, d, a, t, 7);
    let h = Number(e & BigInt(4294967295));
    a[t++] = h, h = h >> 8, a[t++] = h, h = h >> 8, a[t++] = h, h = h >> 8, a[t++] = h;
    let p = Number(e >> BigInt(32) & BigInt(4294967295));
    return a[t++] = p, p = p >> 8, a[t++] = p, p = p >> 8, a[t++] = p, p = p >> 8, a[t++] = p, t;
  }
  function Ru(a, e, t, c, d) {
    ce(e, c, d, a, t, 7);
    let h = Number(e & BigInt(4294967295));
    a[t + 7] = h, h = h >> 8, a[t + 6] = h, h = h >> 8, a[t + 5] = h, h = h >> 8, a[t + 4] = h;
    let p = Number(e >> BigInt(32) & BigInt(4294967295));
    return a[t + 3] = p, p = p >> 8, a[t + 2] = p, p = p >> 8, a[t + 1] = p, p = p >> 8, a[t] = p, t + 8;
  }
  s.prototype.writeBigUInt64LE = bu(function(e, t = 0) {
    return X(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = bu(function(e, t = 0) {
    return Ru(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, !d) {
      const P = Math.pow(2, 8 * c - 1);
      z(this, e, t, c, P - 1, -P);
    }
    let h = 0, p = 1, N = 0;
    for (this[t] = e & 255; ++h < c && (p *= 256); )
      e < 0 && N === 0 && this[t + h - 1] !== 0 && (N = 1), this[t + h] = (e / p >> 0) - N & 255;
    return t + c;
  }, s.prototype.writeIntBE = function(e, t, c, d) {
    if (e = +e, t = t >>> 0, !d) {
      const P = Math.pow(2, 8 * c - 1);
      z(this, e, t, c, P - 1, -P);
    }
    let h = c - 1, p = 1, N = 0;
    for (this[t + h] = e & 255; --h >= 0 && (p *= 256); )
      e < 0 && N === 0 && this[t + h + 1] !== 0 && (N = 1), this[t + h] = (e / p >> 0) - N & 255;
    return t + c;
  }, s.prototype.writeInt8 = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
  }, s.prototype.writeInt16LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, s.prototype.writeInt16BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, s.prototype.writeInt32LE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
  }, s.prototype.writeInt32BE = function(e, t, c) {
    return e = +e, t = t >>> 0, c || z(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  }, s.prototype.writeBigInt64LE = bu(function(e, t = 0) {
    return X(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = bu(function(e, t = 0) {
    return Ru(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ou(a, e, t, c, d, h) {
    if (t + c > a.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function Mu(a, e, t, c, d) {
    return e = +e, t = t >>> 0, d || Ou(a, e, t, 4), i.write(a, e, t, c, 23, 4), t + 4;
  }
  s.prototype.writeFloatLE = function(e, t, c) {
    return Mu(this, e, t, !0, c);
  }, s.prototype.writeFloatBE = function(e, t, c) {
    return Mu(this, e, t, !1, c);
  };
  function Du(a, e, t, c, d) {
    return e = +e, t = t >>> 0, d || Ou(a, e, t, 8), i.write(a, e, t, c, 52, 8), t + 8;
  }
  s.prototype.writeDoubleLE = function(e, t, c) {
    return Du(this, e, t, !0, c);
  }, s.prototype.writeDoubleBE = function(e, t, c) {
    return Du(this, e, t, !1, c);
  }, s.prototype.copy = function(e, t, c, d) {
    if (!s.isBuffer(e))
      throw new TypeError("argument should be a Buffer");
    if (c || (c = 0), !d && d !== 0 && (d = this.length), t >= e.length && (t = e.length), t || (t = 0), d > 0 && d < c && (d = c), d === c || e.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (c < 0 || c >= this.length)
      throw new RangeError("Index out of range");
    if (d < 0)
      throw new RangeError("sourceEnd out of bounds");
    d > this.length && (d = this.length), e.length - t < d - c && (d = e.length - t + c);
    const h = d - c;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, c, d) : Uint8Array.prototype.set.call(
      e,
      this.subarray(c, d),
      t
    ), h;
  }, s.prototype.fill = function(e, t, c, d) {
    if (typeof e == "string") {
      if (typeof t == "string" ? (d = t, t = 0, c = this.length) : typeof c == "string" && (d = c, c = this.length), d !== void 0 && typeof d != "string")
        throw new TypeError("encoding must be a string");
      if (typeof d == "string" && !s.isEncoding(d))
        throw new TypeError("Unknown encoding: " + d);
      if (e.length === 1) {
        const p = e.charCodeAt(0);
        (d === "utf8" && p < 128 || d === "latin1") && (e = p);
      }
    } else
      typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < c)
      throw new RangeError("Out of range index");
    if (c <= t)
      return this;
    t = t >>> 0, c = c === void 0 ? this.length : c >>> 0, e || (e = 0);
    let h;
    if (typeof e == "number")
      for (h = t; h < c; ++h)
        this[h] = e;
    else {
      const p = s.isBuffer(e) ? e : s.from(e, d), N = p.length;
      if (N === 0)
        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (h = 0; h < c - t; ++h)
        this[h + t] = p[h % N];
    }
    return this;
  };
  const tu = {};
  function zu(a, e, t) {
    tu[a] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: e.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${a}]`, this.stack, delete this.name;
      }
      get code() {
        return a;
      }
      set code(d) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: d,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${a}]: ${this.message}`;
      }
    };
  }
  zu(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(a) {
      return a ? `${a} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), zu(
    "ERR_INVALID_ARG_TYPE",
    function(a, e) {
      return `The "${a}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  ), zu(
    "ERR_OUT_OF_RANGE",
    function(a, e, t) {
      let c = `The value of "${a}" is out of range.`, d = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? d = ne(String(t)) : typeof t == "bigint" && (d = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (d = ne(d)), d += "n"), c += ` It must be ${e}. Received ${d}`, c;
    },
    RangeError
  );
  function ne(a) {
    let e = "", t = a.length;
    const c = a[0] === "-" ? 1 : 0;
    for (; t >= c + 4; t -= 3)
      e = `_${a.slice(t - 3, t)}${e}`;
    return `${a.slice(0, t)}${e}`;
  }
  function Pe(a, e, t) {
    Tu(e, "offset"), (a[e] === void 0 || a[e + t] === void 0) && Uu(e, a.length - (t + 1));
  }
  function ce(a, e, t, c, d, h) {
    if (a > t || a < e) {
      const p = typeof e == "bigint" ? "n" : "";
      let N;
      throw h > 3 ? e === 0 || e === BigInt(0) ? N = `>= 0${p} and < 2${p} ** ${(h + 1) * 8}${p}` : N = `>= -(2${p} ** ${(h + 1) * 8 - 1}${p}) and < 2 ** ${(h + 1) * 8 - 1}${p}` : N = `>= ${e}${p} and <= ${t}${p}`, new tu.ERR_OUT_OF_RANGE("value", N, a);
    }
    Pe(c, d, h);
  }
  function Tu(a, e) {
    if (typeof a != "number")
      throw new tu.ERR_INVALID_ARG_TYPE(e, "number", a);
  }
  function Uu(a, e, t) {
    throw Math.floor(a) !== a ? (Tu(a, t), new tu.ERR_OUT_OF_RANGE(t || "offset", "an integer", a)) : e < 0 ? new tu.ERR_BUFFER_OUT_OF_BOUNDS() : new tu.ERR_OUT_OF_RANGE(
      t || "offset",
      `>= ${t ? 1 : 0} and <= ${e}`,
      a
    );
  }
  const Oe = /[^+/0-9A-Za-z-_]/g;
  function Me(a) {
    if (a = a.split("=")[0], a = a.trim().replace(Oe, ""), a.length < 2)
      return "";
    for (; a.length % 4 !== 0; )
      a = a + "=";
    return a;
  }
  function Xu(a, e) {
    e = e || 1 / 0;
    let t;
    const c = a.length;
    let d = null;
    const h = [];
    for (let p = 0; p < c; ++p) {
      if (t = a.charCodeAt(p), t > 55295 && t < 57344) {
        if (!d) {
          if (t > 56319) {
            (e -= 3) > -1 && h.push(239, 191, 189);
            continue;
          } else if (p + 1 === c) {
            (e -= 3) > -1 && h.push(239, 191, 189);
            continue;
          }
          d = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && h.push(239, 191, 189), d = t;
          continue;
        }
        t = (d - 55296 << 10 | t - 56320) + 65536;
      } else
        d && (e -= 3) > -1 && h.push(239, 191, 189);
      if (d = null, t < 128) {
        if ((e -= 1) < 0)
          break;
        h.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0)
          break;
        h.push(
          t >> 6 | 192,
          t & 63 | 128
        );
      } else if (t < 65536) {
        if ((e -= 3) < 0)
          break;
        h.push(
          t >> 12 | 224,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else if (t < 1114112) {
        if ((e -= 4) < 0)
          break;
        h.push(
          t >> 18 | 240,
          t >> 12 & 63 | 128,
          t >> 6 & 63 | 128,
          t & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return h;
  }
  function Ve(a) {
    const e = [];
    for (let t = 0; t < a.length; ++t)
      e.push(a.charCodeAt(t) & 255);
    return e;
  }
  function je(a, e) {
    let t, c, d;
    const h = [];
    for (let p = 0; p < a.length && !((e -= 2) < 0); ++p)
      t = a.charCodeAt(p), c = t >> 8, d = t % 256, h.push(d), h.push(c);
    return h;
  }
  function se(a) {
    return u.toByteArray(Me(a));
  }
  function Vu(a, e, t, c) {
    let d;
    for (d = 0; d < c && !(d + t >= e.length || d >= a.length); ++d)
      e[d + t] = a[d];
    return d;
  }
  function ru(a, e) {
    return a instanceof e || a != null && a.constructor != null && a.constructor.name != null && a.constructor.name === e.name;
  }
  function Qu(a) {
    return a !== a;
  }
  const We = function() {
    const a = "0123456789abcdef", e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      const c = t * 16;
      for (let d = 0; d < 16; ++d)
        e[c + d] = a[t] + a[d];
    }
    return e;
  }();
  function bu(a) {
    return typeof BigInt > "u" ? He : a;
  }
  function He() {
    throw new Error("BigInt not supported");
  }
})(qe);
var ke = { exports: {} }, j = ke.exports = {}, au, nu;
function te() {
  throw new Error("setTimeout has not been defined");
}
function re() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? au = setTimeout : au = te;
  } catch {
    au = te;
  }
  try {
    typeof clearTimeout == "function" ? nu = clearTimeout : nu = re;
  } catch {
    nu = re;
  }
})();
function Re(r) {
  if (au === setTimeout)
    return setTimeout(r, 0);
  if ((au === te || !au) && setTimeout)
    return au = setTimeout, setTimeout(r, 0);
  try {
    return au(r, 0);
  } catch {
    try {
      return au.call(null, r, 0);
    } catch {
      return au.call(this, r, 0);
    }
  }
}
function z0(r) {
  if (nu === clearTimeout)
    return clearTimeout(r);
  if ((nu === re || !nu) && clearTimeout)
    return nu = clearTimeout, clearTimeout(r);
  try {
    return nu(r);
  } catch {
    try {
      return nu.call(null, r);
    } catch {
      return nu.call(this, r);
    }
  }
}
var lu = [], Lu = !1, Iu, Hu = -1;
function X0() {
  !Lu || !Iu || (Lu = !1, Iu.length ? lu = Iu.concat(lu) : Hu = -1, lu.length && De());
}
function De() {
  if (!Lu) {
    var r = Re(X0);
    Lu = !0;
    for (var u = lu.length; u; ) {
      for (Iu = lu, lu = []; ++Hu < u; )
        Iu && Iu[Hu].run();
      Hu = -1, u = lu.length;
    }
    Iu = null, Lu = !1, z0(r);
  }
}
j.nextTick = function(r) {
  var u = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var i = 1; i < arguments.length; i++)
      u[i - 1] = arguments[i];
  lu.push(new Ue(r, u)), lu.length === 1 && !Lu && Re(De);
};
function Ue(r, u) {
  this.fun = r, this.array = u;
}
Ue.prototype.run = function() {
  this.fun.apply(null, this.array);
};
j.title = "browser";
j.browser = !0;
j.env = {};
j.argv = [];
j.version = "";
j.versions = {};
function hu() {
}
j.on = hu;
j.addListener = hu;
j.once = hu;
j.off = hu;
j.removeListener = hu;
j.removeAllListeners = hu;
j.emit = hu;
j.prependListener = hu;
j.prependOnceListener = hu;
j.listeners = function(r) {
  return [];
};
j.binding = function(r) {
  throw new Error("process.binding is not supported");
};
j.cwd = function() {
  return "/";
};
j.chdir = function(r) {
  throw new Error("process.chdir is not supported");
};
j.umask = function() {
  return 0;
};
var Q0 = ke.exports;
(function(r) {
  Object.defineProperty(r, Symbol.toStringTag, { value: "Module" });
  const u = qe, i = Q0, n = (f) => f && f.__esModule ? f : { default: f }, o = n(i), l = globalThis || void 0 || self;
  Object.defineProperty(r, "Buffer", { enumerable: !0, get: () => u.Buffer }), Object.defineProperty(r, "process", { enumerable: !0, get: () => o.default }), r.global = l;
})(Le);
function iu(r) {
  if (typeof r != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(r));
}
function Ee(r, u) {
  for (var i = "", n = 0, o = -1, l = 0, f, s = 0; s <= r.length; ++s) {
    if (s < r.length)
      f = r.charCodeAt(s);
    else {
      if (f === 47)
        break;
      f = 47;
    }
    if (f === 47) {
      if (!(o === s - 1 || l === 1))
        if (o !== s - 1 && l === 2) {
          if (i.length < 2 || n !== 2 || i.charCodeAt(i.length - 1) !== 46 || i.charCodeAt(i.length - 2) !== 46) {
            if (i.length > 2) {
              var m = i.lastIndexOf("/");
              if (m !== i.length - 1) {
                m === -1 ? (i = "", n = 0) : (i = i.slice(0, m), n = i.length - 1 - i.lastIndexOf("/")), o = s, l = 0;
                continue;
              }
            } else if (i.length === 2 || i.length === 1) {
              i = "", n = 0, o = s, l = 0;
              continue;
            }
          }
          u && (i.length > 0 ? i += "/.." : i = "..", n = 2);
        } else
          i.length > 0 ? i += "/" + r.slice(o + 1, s) : i = r.slice(o + 1, s), n = s - o - 1;
      o = s, l = 0;
    } else
      f === 46 && l !== -1 ? ++l : l = -1;
  }
  return i;
}
function J0(r, u) {
  var i = u.dir || u.root, n = u.base || (u.name || "") + (u.ext || "");
  return i ? i === u.root ? i + n : i + r + n : n;
}
var qu = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var u = "", i = !1, n, o = arguments.length - 1; o >= -1 && !i; o--) {
      var l;
      o >= 0 ? l = arguments[o] : (n === void 0 && (n = Le.process.cwd()), l = n), iu(l), l.length !== 0 && (u = l + "/" + u, i = l.charCodeAt(0) === 47);
    }
    return u = Ee(u, !i), i ? u.length > 0 ? "/" + u : "/" : u.length > 0 ? u : ".";
  },
  normalize: function(u) {
    if (iu(u), u.length === 0)
      return ".";
    var i = u.charCodeAt(0) === 47, n = u.charCodeAt(u.length - 1) === 47;
    return u = Ee(u, !i), u.length === 0 && !i && (u = "."), u.length > 0 && n && (u += "/"), i ? "/" + u : u;
  },
  isAbsolute: function(u) {
    return iu(u), u.length > 0 && u.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var u, i = 0; i < arguments.length; ++i) {
      var n = arguments[i];
      iu(n), n.length > 0 && (u === void 0 ? u = n : u += "/" + n);
    }
    return u === void 0 ? "." : qu.normalize(u);
  },
  relative: function(u, i) {
    if (iu(u), iu(i), u === i || (u = qu.resolve(u), i = qu.resolve(i), u === i))
      return "";
    for (var n = 1; n < u.length && u.charCodeAt(n) === 47; ++n)
      ;
    for (var o = u.length, l = o - n, f = 1; f < i.length && i.charCodeAt(f) === 47; ++f)
      ;
    for (var s = i.length, m = s - f, w = l < m ? l : m, I = -1, y = 0; y <= w; ++y) {
      if (y === w) {
        if (m > w) {
          if (i.charCodeAt(f + y) === 47)
            return i.slice(f + y + 1);
          if (y === 0)
            return i.slice(f + y);
        } else
          l > w && (u.charCodeAt(n + y) === 47 ? I = y : y === 0 && (I = 0));
        break;
      }
      var q = u.charCodeAt(n + y), B = i.charCodeAt(f + y);
      if (q !== B)
        break;
      q === 47 && (I = y);
    }
    var v = "";
    for (y = n + I + 1; y <= o; ++y)
      (y === o || u.charCodeAt(y) === 47) && (v.length === 0 ? v += ".." : v += "/..");
    return v.length > 0 ? v + i.slice(f + I) : (f += I, i.charCodeAt(f) === 47 && ++f, i.slice(f));
  },
  _makeLong: function(u) {
    return u;
  },
  dirname: function(u) {
    if (iu(u), u.length === 0)
      return ".";
    for (var i = u.charCodeAt(0), n = i === 47, o = -1, l = !0, f = u.length - 1; f >= 1; --f)
      if (i = u.charCodeAt(f), i === 47) {
        if (!l) {
          o = f;
          break;
        }
      } else
        l = !1;
    return o === -1 ? n ? "/" : "." : n && o === 1 ? "//" : u.slice(0, o);
  },
  basename: function(u, i) {
    if (i !== void 0 && typeof i != "string")
      throw new TypeError('"ext" argument must be a string');
    iu(u);
    var n = 0, o = -1, l = !0, f;
    if (i !== void 0 && i.length > 0 && i.length <= u.length) {
      if (i.length === u.length && i === u)
        return "";
      var s = i.length - 1, m = -1;
      for (f = u.length - 1; f >= 0; --f) {
        var w = u.charCodeAt(f);
        if (w === 47) {
          if (!l) {
            n = f + 1;
            break;
          }
        } else
          m === -1 && (l = !1, m = f + 1), s >= 0 && (w === i.charCodeAt(s) ? --s === -1 && (o = f) : (s = -1, o = m));
      }
      return n === o ? o = m : o === -1 && (o = u.length), u.slice(n, o);
    } else {
      for (f = u.length - 1; f >= 0; --f)
        if (u.charCodeAt(f) === 47) {
          if (!l) {
            n = f + 1;
            break;
          }
        } else
          o === -1 && (l = !1, o = f + 1);
      return o === -1 ? "" : u.slice(n, o);
    }
  },
  extname: function(u) {
    iu(u);
    for (var i = -1, n = 0, o = -1, l = !0, f = 0, s = u.length - 1; s >= 0; --s) {
      var m = u.charCodeAt(s);
      if (m === 47) {
        if (!l) {
          n = s + 1;
          break;
        }
        continue;
      }
      o === -1 && (l = !1, o = s + 1), m === 46 ? i === -1 ? i = s : f !== 1 && (f = 1) : i !== -1 && (f = -1);
    }
    return i === -1 || o === -1 || // We saw a non-dot character immediately before the dot
    f === 0 || // The (right-most) trimmed path component is exactly '..'
    f === 1 && i === o - 1 && i === n + 1 ? "" : u.slice(i, o);
  },
  format: function(u) {
    if (u === null || typeof u != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof u);
    return J0("/", u);
  },
  parse: function(u) {
    iu(u);
    var i = { root: "", dir: "", base: "", ext: "", name: "" };
    if (u.length === 0)
      return i;
    var n = u.charCodeAt(0), o = n === 47, l;
    o ? (i.root = "/", l = 1) : l = 0;
    for (var f = -1, s = 0, m = -1, w = !0, I = u.length - 1, y = 0; I >= l; --I) {
      if (n = u.charCodeAt(I), n === 47) {
        if (!w) {
          s = I + 1;
          break;
        }
        continue;
      }
      m === -1 && (w = !1, m = I + 1), n === 46 ? f === -1 ? f = I : y !== 1 && (y = 1) : f !== -1 && (y = -1);
    }
    return f === -1 || m === -1 || // We saw a non-dot character immediately before the dot
    y === 0 || // The (right-most) trimmed path component is exactly '..'
    y === 1 && f === m - 1 && f === s + 1 ? m !== -1 && (s === 0 && o ? i.base = i.name = u.slice(1, m) : i.base = i.name = u.slice(s, m)) : (s === 0 && o ? (i.name = u.slice(1, f), i.base = u.slice(1, m)) : (i.name = u.slice(s, f), i.base = u.slice(s, m)), i.ext = u.slice(f, m)), s > 0 ? i.dir = u.slice(0, s - 1) : o && (i.dir = "/"), i;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
qu.posix = qu;
var Z0 = qu, Ce = {};
(function(r) {
  var u = /[|\\{}()[\]^$+*?.]/g, i = Object.prototype.hasOwnProperty, n = function(w, I) {
    return i.apply(w, [I]);
  };
  r.escapeRegExpChars = function(w) {
    return w ? String(w).replace(u, "\\$&") : "";
  };
  var o = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&#34;",
    "'": "&#39;"
  }, l = /[&<>'"]/g;
  function f(w) {
    return o[w] || w;
  }
  var s = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
  r.escapeXML = function(w) {
    return w == null ? "" : String(w).replace(l, f);
  };
  function m() {
    return Function.prototype.toString.call(this) + `;
` + s;
  }
  try {
    typeof Object.defineProperty == "function" ? Object.defineProperty(r.escapeXML, "toString", { value: m }) : r.escapeXML.toString = m;
  } catch {
    console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
  }
  r.shallowCopy = function(w, I) {
    if (I = I || {}, w != null)
      for (var y in I)
        n(I, y) && (y === "__proto__" || y === "constructor" || (w[y] = I[y]));
    return w;
  }, r.shallowCopyFromList = function(w, I, y) {
    if (y = y || [], I = I || {}, w != null)
      for (var q = 0; q < y.length; q++) {
        var B = y[q];
        if (typeof I[B] < "u") {
          if (!n(I, B) || B === "__proto__" || B === "constructor")
            continue;
          w[B] = I[B];
        }
      }
    return w;
  }, r.cache = {
    _data: {},
    set: function(w, I) {
      this._data[w] = I;
    },
    get: function(w) {
      return this._data[w];
    },
    remove: function(w) {
      delete this._data[w];
    },
    reset: function() {
      this._data = {};
    }
  }, r.hyphenToCamel = function(w) {
    return w.replace(/-[a-z]/g, function(I) {
      return I[1].toUpperCase();
    });
  }, r.createNullProtoObjWherePossible = function() {
    return typeof Object.create == "function" ? function() {
      return /* @__PURE__ */ Object.create(null);
    } : { __proto__: null } instanceof Object ? function() {
      return {};
    } : function() {
      return { __proto__: null };
    };
  }();
})(Ce);
const Y0 = "ejs", K0 = "Embedded JavaScript templates", ut = [
  "template",
  "engine",
  "ejs"
], et = "3.1.9", tt = "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)", rt = "Apache-2.0", it = {
  ejs: "./bin/cli.js"
}, at = "./lib/ejs.js", nt = "ejs.min.js", ct = "ejs.min.js", st = {
  type: "git",
  url: "git://github.com/mde/ejs.git"
}, ot = "https://github.com/mde/ejs/issues", ft = "https://github.com/mde/ejs", dt = {
  jake: "^10.8.5"
}, lt = {
  browserify: "^16.5.1",
  eslint: "^6.8.0",
  "git-directory-deploy": "^1.5.1",
  jsdoc: "^4.0.2",
  "lru-cache": "^4.0.1",
  mocha: "^10.2.0",
  "uglify-js": "^3.3.16"
}, ht = {
  node: ">=0.10.0"
}, bt = {
  test: "mocha -u tdd"
}, pt = {
  name: Y0,
  description: K0,
  keywords: ut,
  version: et,
  author: tt,
  license: rt,
  bin: it,
  main: at,
  jsdelivr: nt,
  unpkg: ct,
  repository: st,
  bugs: ot,
  homepage: ft,
  dependencies: dt,
  devDependencies: lt,
  engines: ht,
  scripts: bt
};
(function(r) {
  /**
   * @file Embedded JavaScript templating engine. {@link http://ejs.co}
   * @author Matthew Eernisse <mde@fleegix.org>
   * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
   * @project EJS
   * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
   */
  var u = P0, i = Z0, n = Ce, o = !1, l = pt.version, f = "<", s = ">", m = "%", w = "locals", I = "ejs", y = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)", q = [
    "delimiter",
    "scope",
    "context",
    "debug",
    "compileDebug",
    "client",
    "_with",
    "rmWhitespace",
    "strict",
    "filename",
    "async"
  ], B = q.concat("cache"), v = /^\uFEFF/, S = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
  r.cache = n.cache, r.fileLoader = u.readFileSync, r.localsName = w, r.promiseImpl = new Function("return this;")().Promise, r.resolveInclude = function(x, E, b) {
    var A = i.dirname, _ = i.extname, k = i.resolve, W = k(b ? E : A(E), x), eu = _(x);
    return eu || (W += ".ejs"), W;
  };
  function C(x, E) {
    var b;
    if (E.some(function(A) {
      return b = r.resolveInclude(x, A, !0), u.existsSync(b);
    }))
      return b;
  }
  function H(x, E) {
    var b, A, _ = E.views, k = /^[A-Za-z]+:\\|^\//.exec(x);
    if (k && k.length)
      x = x.replace(/^\/*/, ""), Array.isArray(E.root) ? b = C(x, E.root) : b = r.resolveInclude(x, E.root || "/", !0);
    else if (E.filename && (A = r.resolveInclude(x, E.filename), u.existsSync(A) && (b = A)), !b && Array.isArray(_) && (b = C(x, _)), !b && typeof E.includer != "function")
      throw new Error('Could not find the include file "' + E.escapeFunction(x) + '"');
    return b;
  }
  function M(x, E) {
    var b, A = x.filename, _ = arguments.length > 1;
    if (x.cache) {
      if (!A)
        throw new Error("cache option requires a filename");
      if (b = r.cache.get(A), b)
        return b;
      _ || (E = gu(A).toString().replace(v, ""));
    } else if (!_) {
      if (!A)
        throw new Error("Internal EJS error: no file name or template provided");
      E = gu(A).toString().replace(v, "");
    }
    return b = r.compile(E, x), x.cache && r.cache.set(A, b), b;
  }
  function J(x, E, b) {
    var A;
    if (b) {
      try {
        A = M(x)(E);
      } catch (_) {
        return b(_);
      }
      b(null, A);
    } else {
      if (typeof r.promiseImpl == "function")
        return new r.promiseImpl(function(_, k) {
          try {
            A = M(x)(E), _(A);
          } catch (W) {
            k(W);
          }
        });
      throw new Error("Please provide a callback function");
    }
  }
  function gu(x) {
    return r.fileLoader(x);
  }
  function uu(x, E) {
    var b = n.shallowCopy(n.createNullProtoObjWherePossible(), E);
    if (b.filename = H(x, b), typeof E.includer == "function") {
      var A = E.includer(x, b.filename);
      if (A && (A.filename && (b.filename = A.filename), A.template))
        return M(b, A.template);
    }
    return M(b);
  }
  function wu(x, E, b, A, _) {
    var k = E.split(`
`), W = Math.max(A - 3, 0), eu = Math.min(k.length, A + 3), Z = _(b), fu = k.slice(W, eu).map(function(yu, vu) {
      var D = vu + W + 1;
      return (D == A ? " >> " : "    ") + D + "| " + yu;
    }).join(`
`);
    throw x.path = Z, x.message = (Z || "ejs") + ":" + A + `
` + fu + `

` + x.message, x;
  }
  function ku(x) {
    return x.replace(/;(\s*$)/, "$1");
  }
  r.compile = function(E, b) {
    var A;
    return b && b.scope && (o || (console.warn("`scope` option is deprecated and will be removed in EJS 3"), o = !0), b.context || (b.context = b.scope), delete b.scope), A = new V(E, b), A.compile();
  }, r.render = function(x, E, b) {
    var A = E || n.createNullProtoObjWherePossible(), _ = b || n.createNullProtoObjWherePossible();
    return arguments.length == 2 && n.shallowCopyFromList(_, A, q), M(_, x)(A);
  }, r.renderFile = function() {
    var x = Array.prototype.slice.call(arguments), E = x.shift(), b, A = { filename: E }, _, k;
    return typeof arguments[arguments.length - 1] == "function" && (b = x.pop()), x.length ? (_ = x.shift(), x.length ? n.shallowCopy(A, x.pop()) : (_.settings && (_.settings.views && (A.views = _.settings.views), _.settings["view cache"] && (A.cache = !0), k = _.settings["view options"], k && n.shallowCopy(A, k)), n.shallowCopyFromList(A, _, B)), A.filename = E) : _ = n.createNullProtoObjWherePossible(), J(A, _, b);
  }, r.Template = V, r.clearCache = function() {
    r.cache.reset();
  };
  function V(x, E) {
    E = E || n.createNullProtoObjWherePossible();
    var b = n.createNullProtoObjWherePossible();
    this.templateText = x, this.mode = null, this.truncate = !1, this.currentLine = 1, this.source = "", b.client = E.client || !1, b.escapeFunction = E.escape || E.escapeFunction || n.escapeXML, b.compileDebug = E.compileDebug !== !1, b.debug = !!E.debug, b.filename = E.filename, b.openDelimiter = E.openDelimiter || r.openDelimiter || f, b.closeDelimiter = E.closeDelimiter || r.closeDelimiter || s, b.delimiter = E.delimiter || r.delimiter || m, b.strict = E.strict || !1, b.context = E.context, b.cache = E.cache || !1, b.rmWhitespace = E.rmWhitespace, b.root = E.root, b.includer = E.includer, b.outputFunctionName = E.outputFunctionName, b.localsName = E.localsName || r.localsName || w, b.views = E.views, b.async = E.async, b.destructuredLocals = E.destructuredLocals, b.legacyInclude = typeof E.legacyInclude < "u" ? !!E.legacyInclude : !0, b.strict ? b._with = !1 : b._with = typeof E._with < "u" ? E._with : !0, this.opts = b, this.regex = this.createRegex();
  }
  V.modes = {
    EVAL: "eval",
    ESCAPED: "escaped",
    RAW: "raw",
    COMMENT: "comment",
    LITERAL: "literal"
  }, V.prototype = {
    createRegex: function() {
      var x = y, E = n.escapeRegExpChars(this.opts.delimiter), b = n.escapeRegExpChars(this.opts.openDelimiter), A = n.escapeRegExpChars(this.opts.closeDelimiter);
      return x = x.replace(/%/g, E).replace(/</g, b).replace(/>/g, A), new RegExp(x);
    },
    compile: function() {
      var x, E, b = this.opts, A = "", _ = "", k = b.escapeFunction, W, eu = b.filename ? JSON.stringify(b.filename) : "undefined";
      if (!this.source) {
        if (this.generateSource(), A += `  var __output = "";
  function __append(s) { if (s !== undefined && s !== null) __output += s }
`, b.outputFunctionName) {
          if (!S.test(b.outputFunctionName))
            throw new Error("outputFunctionName is not a valid JS identifier.");
          A += "  var " + b.outputFunctionName + ` = __append;
`;
        }
        if (b.localsName && !S.test(b.localsName))
          throw new Error("localsName is not a valid JS identifier.");
        if (b.destructuredLocals && b.destructuredLocals.length) {
          for (var Z = "  var __locals = (" + b.localsName + ` || {}),
`, fu = 0; fu < b.destructuredLocals.length; fu++) {
            var yu = b.destructuredLocals[fu];
            if (!S.test(yu))
              throw new Error("destructuredLocals[" + fu + "] is not a valid JS identifier.");
            fu > 0 && (Z += `,
  `), Z += yu + " = __locals." + yu;
          }
          A += Z + `;
`;
        }
        b._with !== !1 && (A += "  with (" + b.localsName + ` || {}) {
`, _ += `  }
`), _ += `  return __output;
`, this.source = A + this.source + _;
      }
      b.compileDebug ? x = `var __line = 1
  , __lines = ` + JSON.stringify(this.templateText) + `
  , __filename = ` + eu + `;
try {
` + this.source + `} catch (e) {
  rethrow(e, __lines, __filename, __line, escapeFn);
}
` : x = this.source, b.client && (x = "escapeFn = escapeFn || " + k.toString() + `;
` + x, b.compileDebug && (x = "rethrow = rethrow || " + wu.toString() + `;
` + x)), b.strict && (x = `"use strict";
` + x), b.debug && console.log(x), b.compileDebug && b.filename && (x = x + `
//# sourceURL=` + eu + `
`);
      try {
        if (b.async)
          try {
            W = new Function("return (async function(){}).constructor;")();
          } catch (X) {
            throw X instanceof SyntaxError ? new Error("This environment does not support async/await") : X;
          }
        else
          W = Function;
        E = new W(b.localsName + ", escapeFn, include, rethrow", x);
      } catch (X) {
        throw X instanceof SyntaxError && (b.filename && (X.message += " in " + b.filename), X.message += ` while compiling ejs

`, X.message += `If the above error is not helpful, you may want to try EJS-Lint:
`, X.message += "https://github.com/RyanZim/EJS-Lint", b.async || (X.message += `
`, X.message += "Or, if you meant to create an async function, pass `async: true` as an option.")), X;
      }
      var vu = b.client ? E : function(Ru) {
        var Ou = function(Mu, Du) {
          var tu = n.shallowCopy(n.createNullProtoObjWherePossible(), Ru);
          return Du && (tu = n.shallowCopy(tu, Du)), uu(Mu, b)(tu);
        };
        return E.apply(
          b.context,
          [Ru || n.createNullProtoObjWherePossible(), k, Ou, wu]
        );
      };
      if (b.filename && typeof Object.defineProperty == "function") {
        var D = b.filename, z = i.basename(D, i.extname(D));
        try {
          Object.defineProperty(vu, "name", {
            value: z,
            writable: !1,
            enumerable: !1,
            configurable: !0
          });
        } catch {
        }
      }
      return vu;
    },
    generateSource: function() {
      var x = this.opts;
      x.rmWhitespace && (this.templateText = this.templateText.replace(/[\r\n]+/g, `
`).replace(/^\s+|\s+$/gm, "")), this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
      var E = this, b = this.parseTemplateText(), A = this.opts.delimiter, _ = this.opts.openDelimiter, k = this.opts.closeDelimiter;
      b && b.length && b.forEach(function(W, eu) {
        var Z;
        if (W.indexOf(_ + A) === 0 && W.indexOf(_ + A + A) !== 0 && (Z = b[eu + 2], !(Z == A + k || Z == "-" + A + k || Z == "_" + A + k)))
          throw new Error('Could not find matching close tag for "' + W + '".');
        E.scanLine(W);
      });
    },
    parseTemplateText: function() {
      for (var x = this.templateText, E = this.regex, b = E.exec(x), A = [], _; b; )
        _ = b.index, _ !== 0 && (A.push(x.substring(0, _)), x = x.slice(_)), A.push(b[0]), x = x.slice(b[0].length), b = E.exec(x);
      return x && A.push(x), A;
    },
    _addOutput: function(x) {
      if (this.truncate && (x = x.replace(/^(?:\r\n|\r|\n)/, ""), this.truncate = !1), !x)
        return x;
      x = x.replace(/\\/g, "\\\\"), x = x.replace(/\n/g, "\\n"), x = x.replace(/\r/g, "\\r"), x = x.replace(/"/g, '\\"'), this.source += '    ; __append("' + x + `")
`;
    },
    scanLine: function(x) {
      var E = this, b = this.opts.delimiter, A = this.opts.openDelimiter, _ = this.opts.closeDelimiter, k = 0;
      switch (k = x.split(`
`).length - 1, x) {
        case A + b:
        case A + b + "_":
          this.mode = V.modes.EVAL;
          break;
        case A + b + "=":
          this.mode = V.modes.ESCAPED;
          break;
        case A + b + "-":
          this.mode = V.modes.RAW;
          break;
        case A + b + "#":
          this.mode = V.modes.COMMENT;
          break;
        case A + b + b:
          this.mode = V.modes.LITERAL, this.source += '    ; __append("' + x.replace(A + b + b, A + b) + `")
`;
          break;
        case b + b + _:
          this.mode = V.modes.LITERAL, this.source += '    ; __append("' + x.replace(b + b + _, b + _) + `")
`;
          break;
        case b + _:
        case "-" + b + _:
        case "_" + b + _:
          this.mode == V.modes.LITERAL && this._addOutput(x), this.mode = null, this.truncate = x.indexOf("-") === 0 || x.indexOf("_") === 0;
          break;
        default:
          if (this.mode) {
            switch (this.mode) {
              case V.modes.EVAL:
              case V.modes.ESCAPED:
              case V.modes.RAW:
                x.lastIndexOf("//") > x.lastIndexOf(`
`) && (x += `
`);
            }
            switch (this.mode) {
              case V.modes.EVAL:
                this.source += "    ; " + x + `
`;
                break;
              case V.modes.ESCAPED:
                this.source += "    ; __append(escapeFn(" + ku(x) + `))
`;
                break;
              case V.modes.RAW:
                this.source += "    ; __append(" + ku(x) + `)
`;
                break;
              case V.modes.COMMENT:
                break;
              case V.modes.LITERAL:
                this._addOutput(x);
                break;
            }
          } else
            this._addOutput(x);
      }
      E.opts.compileDebug && k && (this.currentLine += k, this.source += "    ; __line = " + this.currentLine + `
`);
    }
  }, r.escapeXML = n.escapeXML, r.__express = r.renderFile, r.VERSION = l, r.name = I, typeof window < "u" && (window.ejs = r);
})(Ne);
const mt = /* @__PURE__ */ n0(Ne);
function xt(r, u) {
  let i = u == null || u === "" ? {} : JSON.parse(u);
  return mt.render(r, i, {
    rmWhitespace: !0
  });
}
function gt(r) {
  let u = new Gu("root"), i = [];
  const n = new a0({
    onopentag(o, l) {
      _0(o);
      let f = B0(l.style), s = N0(o), m = new Gu(o, {
        attrs: l,
        style: f,
        display: s
      });
      u.children.push(m), i.push(u), u = m;
    },
    ontext(o) {
      o = o.replace(/[\r\n]/g, ""), u.children.push(new _e(o));
    },
    onclosetag(o) {
      u = i.pop();
    }
  });
  return n.write(r), n.end(), u;
}
function wt(r, u) {
  return new D0(u).layout(r);
}
function St(r, u, i) {
  let n = xt(r, u), o = gt(n);
  return wt(o, i);
}
export {
  T0 as BarcodePrintNodeModel,
  Cu as FontStyle,
  S0 as ImagePrintNodeModel,
  Et as LayoutError,
  Su as LinePrintNodeModel,
  I0 as ParseError,
  Fu as PrintNodeModel,
  K as PrintType,
  v0 as QRCodePrintNodeModel,
  pu as TextChildPrintNodeModel,
  Nu as TextDecorationLine,
  Eu as TextPrintNodeModel,
  At as TypographyOptions,
  St as compilePrintNodes,
  gt as htmlParseAST,
  xt as renderTmp,
  wt as typographyAST
};
